<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Bacterial Finches</title>
    <link>http://sam217pa.github.io/post/</link>
    <description>Recent content in Posts on Bacterial Finches</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Samuel Barreto</copyright>
    <lastBuildDate>Tue, 05 Jul 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://sam217pa.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Functional Programming In R</title>
      <link>http://sam217pa.github.io/2016/07/05/functional-programming-in-r/</link>
      <pubDate>Tue, 05 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>http://sam217pa.github.io/2016/07/05/functional-programming-in-r/</guid>
      <description>

&lt;p&gt;Functional programming is a style of programming which place the emphasis on
functions. Functions helps to clearly express the intent of a piece of code. To
me, &lt;code&gt;R&lt;/code&gt; is a functional language. Its deep roots goes back to Scheme, a
functional LISP dialect. The imperative part of &lt;code&gt;R&lt;/code&gt; are to be found in its &lt;code&gt;S&lt;/code&gt;
legacy. In this post, I want to describe how I use functions in R, mixing
imperative and purely functional programming.&lt;/p&gt;

&lt;p&gt;I will take as an example an analysis I&amp;rsquo;ve done in the past few months. It was a
quick one day long analysis, but I think it would have been much longer if I had
not used
R&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:6a5bf84d7e413edf98f3db000dff6cf1:Actually-it-is-t&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:6a5bf84d7e413edf98f3db000dff6cf1:Actually-it-is-t&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;I work in biology. In november, we received results of a run of
&lt;a href=&#34;https://en.wikipedia.org/wiki/Sanger_sequencing&#34;&gt;Sanger sequencing&lt;/a&gt;. It was
done in 96 well plates on 800bp PCR amplicons. We quickly found out that some
sequences showed traces of contamination : we had secondary peak specifically on
our divergence markers. We had reasons to believe that sequences with secondary
peak would be distributed randomly over the 96 well plate if it was not a sign
of contamination. I decided to test the random distribution using a quick
simulation.&lt;/p&gt;

&lt;p&gt;The simulation would do the following :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;generate 96 well plates with as much contaminated well as there were in our
plates.&lt;/li&gt;
&lt;li&gt;generate a lot of those plates.&lt;/li&gt;
&lt;li&gt;per well, count the average number of contaminated well, and average this
count over the plate.&lt;/li&gt;
&lt;li&gt;compare this simulated statistic with the observed one in our plate.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We first need to load some packages.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(assertthat)
library(ggplot2)
library(dplyr)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;functions-express-intent:6a5bf84d7e413edf98f3db000dff6cf1&#34;&gt;Functions express intent&lt;/h1&gt;

&lt;p&gt;We want a simple function to sample a number at random between 1 and n.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;random_well &amp;lt;- function(n) sample(1:n, 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This function does only one simple thing. But it has a name that clearly express
what it does and abstracts the sampling process, so simple as it is.&lt;/p&gt;

&lt;p&gt;We also want a simple function to generate an empty plate, &lt;em&gt;ie&lt;/em&gt; a plate where no
well is contaminated. A 96 well plate can easily be represented as a 8 by 12
matrix.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;initiate_plate &amp;lt;- function() matrix(rep(0, 96), nrow = 8, ncol = 12)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the same manner, the function is really simple, but now I can just call
&lt;code&gt;initiate_plate&lt;/code&gt; and be done with it : I now have an 8 by 12 matrix with 0 all
over, ready to be filled up with simulated contaminations !&lt;/p&gt;

&lt;h1 id=&#34;recursion-shortens-the-distance-from-mind-to-code:6a5bf84d7e413edf98f3db000dff6cf1&#34;&gt;Recursion shortens the distance from mind to code&lt;/h1&gt;

&lt;p&gt;We now want to contaminate &lt;em&gt;n&lt;/em&gt; well inside of this empty plate.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;plate_generate &amp;lt;- function(plate = initiate_plate(), n) {
    assert_that(is.numeric(n), n &amp;lt; 96)

    ## this function contaminate a plate well if it is not already contaminated.
    ## it uses recursion to do so.
    contaminer &amp;lt;- function(mat) {
        x &amp;lt;- random_well(8) # sample one line at random
        y &amp;lt;- random_well(12) # sample one column at random

        if (mat[x, y] != 1) {
            mat[x, y] &amp;lt;- 1
            mat
        } else {
            contaminer(mat)
        }
    }

    ## if the plate already have *n* contaminated wells, return it.
    ## otherwise create a plate with *n - 1* contaminated wells.
    ## this kind of recursion is particularly useful to think about.
    if (sum(plate &amp;lt; n)) {
        ## if the plate does not have n wells contaminated
        contaminer(plate_generate(plate, n - 1))
        ## generate another plate with *n - 1* contaminated wells,
        ## and contaminate another random well.
    } else {
        plate
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;plate_generator&lt;/code&gt; uses recursion. It is a style of function calling that I
believe to be discouraged in R. But as my stack cannot exceed 96, I can use
recursion without worrying too much about overflowing the R stack.&lt;/p&gt;

&lt;p&gt;I have enclosed a function inside of it, since I do not need it outside of this
context. This function, &lt;code&gt;contaminer&lt;/code&gt;, set the well / matrix value to 1 at a
random coordinate if the well is not already at 1. If the well is already
contaminated (equals to 1), I call &lt;code&gt;contaminer&lt;/code&gt; on the plate again : it will
pick another random well, and contaminate it. If the well is already
contaminated (equals to 1), I call &lt;code&gt;contaminer&lt;/code&gt; on the plate again : it will
pick another random well, and contaminate it. If the well is already â€¦ I think
you begin to understand how recursion works.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;plate_generator&lt;/code&gt; uses contaminer to create a matrix with &lt;em&gt;n&lt;/em&gt; contamination
inside, &lt;em&gt;ie n&lt;/em&gt; wells with a 1 value and &lt;em&gt;96 - n&lt;/em&gt; wells with a 0 value. It does
so by first checking if the total count of plate is equals to &lt;em&gt;n&lt;/em&gt;. If not, we
can generate a plate with &lt;em&gt;n - 1&lt;/em&gt; contamination, and add another contamination
with &lt;code&gt;contaminer&lt;/code&gt;. How can we generate a plate with &lt;em&gt;n - 1&lt;/em&gt; contamination ? It
would be great if we had a function that generate a plate with the desired
amount of contamination. Well, it appears we have. This function is called
&lt;code&gt;plate_generator&lt;/code&gt;. If we call &lt;code&gt;plate_generator&lt;/code&gt; with &lt;em&gt;n = n - 1&lt;/em&gt;, it will
contaminate another well ; the plate sum is now equal to &lt;em&gt;n&lt;/em&gt; and we can return
it. But generating a plate with &lt;em&gt;n - 1&lt;/em&gt; contaminated well implies that we have a
plate with &lt;em&gt;n - 2&lt;/em&gt; contaminated well and so on. &lt;strong&gt;This is recursion&lt;/strong&gt;. I have one
function that does one thing and call itself to reach its goal.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;plate_generator&lt;/code&gt; function is useful in the sense that I did not have to
think about it really well. I &lt;em&gt;know&lt;/em&gt; it is not optimised. I know that I can
shorten the time of execution by first excluding wells that are already
contaminated from the parameters space of &lt;code&gt;contaminer&lt;/code&gt;, instead of picking
/ checking / contaminating a well randomly. The function would gain in speed.
But I can generate ten thousands plate on my computer in less than 2 minutes.
The function did not take that long to develop.&lt;/p&gt;

&lt;p&gt;The previous code is maybe a little bit tedious to understand. Anyway, once it
is tested, I do not have to care about how it is done. I can just call the
function, I know it will always give the same result, even if the implementation
change. It is a level of abstraction that clearly helps to develop clean and
clever code by iterative steps. I am not afraid of breaking everything up : I
know my functions does one thing and does it well. &lt;strong&gt;It has no side-effects&lt;/strong&gt;.
This function is pure : it does not modify anything outside its scope.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We now want to generate many random plates, with a finite number of
contamination inside of it.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;running-the-simulation:6a5bf84d7e413edf98f3db000dff6cf1&#34;&gt;Running the simulation&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;n_plate_generate &amp;lt;- function(number_of_plate, number_of_conta) {
    lapply(1:number_of_plate, function(i) plate_generate(n = number_of_conta))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We now can generate three plates with three contaminated wells inside of it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;n_plate_generate(3, 3)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [[1]]
##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
## [1,]    0    0    0    0    0    0    0    0    0     0     1     0
## [2,]    0    0    0    0    0    0    0    0    0     0     0     0
## [3,]    0    0    0    0    0    0    1    0    0     0     0     0
## [4,]    0    0    0    0    0    0    0    0    0     0     0     0
## [5,]    0    0    0    0    0    0    0    0    0     0     0     0
## [6,]    1    0    0    0    0    0    0    0    0     0     0     0
## [7,]    0    0    0    0    0    0    0    0    0     0     0     0
## [8,]    0    0    0    0    0    0    0    0    0     0     0     0
## 
## [[2]]
##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
## [1,]    0    0    0    0    0    0    0    0    0     0     0     0
## [2,]    0    0    0    0    0    0    0    0    0     0     0     0
## [3,]    0    0    1    0    0    0    0    0    0     0     0     0
## [4,]    0    0    0    0    0    0    0    0    0     0     0     0
## [5,]    0    1    0    0    0    0    0    0    0     0     0     0
## [6,]    0    0    0    0    0    0    0    0    0     0     0     0
## [7,]    0    0    0    0    1    0    0    0    0     0     0     0
## [8,]    0    0    0    0    0    0    0    0    0     0     0     0
## 
## [[3]]
##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
## [1,]    0    0    0    0    0    0    0    0    0     0     0     0
## [2,]    0    0    0    0    0    0    0    0    0     0     0     0
## [3,]    0    0    0    0    0    0    1    0    0     0     0     0
## [4,]    0    0    0    0    0    0    0    0    0     0     0     0
## [5,]    0    0    0    0    0    0    0    0    0     0     0     0
## [6,]    0    0    0    0    0    0    0    0    0     0     0     0
## [7,]    0    0    0    0    0    0    0    0    0     0     0     0
## [8,]    0    1    0    1    0    0    0    0    0     0     0     0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We then need to count, per well, the number of neighbouring contaminated well.
This function is kinda tricky to explain, and demands some kind of expertise
with typical biological plates. I had to hardcode many stuff, so I guess this is
not the cleaner way to do it. But at least is works.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;has_nearby_conta &amp;lt;- function(plate, line, column) {
    assert_that(is.matrix(plate), is.numeric(line), is.numeric(column))

    x      &amp;lt;- line
    y      &amp;lt;- column
    p      &amp;lt;- plate
    nearby &amp;lt;- c()

    bord_gauche     &amp;lt;- function(col) ifelse(col == 1 , TRUE, FALSE)
    bord_droite     &amp;lt;- function(col) ifelse(col == 12, TRUE, FALSE)
    bord_sup        &amp;lt;- function(row) ifelse(row == 1 , TRUE, FALSE)
    bord_inf        &amp;lt;- function(row) ifelse(row == 8 , TRUE, FALSE)

    coin_sup_gauche &amp;lt;- function(row, col) ifelse(bord_gauche(col) &amp;amp; bord_sup(row), TRUE, FALSE)
    coin_inf_gauche &amp;lt;- function(row, col) ifelse(bord_gauche(col) &amp;amp; bord_inf(row), TRUE, FALSE)
    coin_inf_droite &amp;lt;- function(row, col) ifelse(bord_droite(col) &amp;amp; bord_inf(row), TRUE, FALSE)
    coin_sup_droite &amp;lt;- function(row, col) ifelse(bord_droite(col) &amp;amp; bord_sup(row), TRUE, FALSE)

    if      (coin_sup_gauche(x, y)) { nearby &amp;lt;- c(nearby, p[x, y+1], p[x+1, y+1], p[x+1, y])}
    else if (coin_inf_gauche(x, y)) { nearby &amp;lt;- c(nearby, p[x-1, y], p[x-1, y+1], p[x, y+1])}
    else if (coin_sup_droite(x, y)) { nearby &amp;lt;- c(nearby, p[x, y-1], p[x+1, y-1], p[x+1, y])}
    else if (coin_inf_droite(x, y)) { nearby &amp;lt;- c(nearby, p[x, y-1], p[x-1, y-1], p[x-1, y])}
    else if (bord_gauche(y))        { nearby &amp;lt;- c(nearby, p[x-1, y], p[x-1, y+1], p[x, y+1], p[x+1, y+1], p[x+1, y])}
    else if (bord_droite(y))        { nearby &amp;lt;- c(nearby, p[x-1, y], p[x-1, y-1], p[x, y-1], p[x+1, y-1], p[x+1, y])}
    else if (bord_sup(x))           { nearby &amp;lt;- c(nearby, p[x, y-1], p[x+1, y-1], p[x+1, y], p[x+1, y+1], p[x, y+1])}
    else if (bord_inf(x))           { nearby &amp;lt;- c(nearby, p[x, y-1], p[x-1, y-1], p[x-1, y], p[x-1, y+1], p[x, y+1])}
    else {
        nearby &amp;lt;- c(nearby,
                    p[x-1, y-1], p[x, y-1], p[x+1, y-1],
                    p[x-1, y  ],            p[x+1, y  ],
                    p[x-1, y+1], p[x, y+1], p[x+1, y+1] )
    }

    ## normalise to 1 if &amp;gt; 1
    nearby[nearby &amp;gt; 0] &amp;lt;- 1

    ## return the mean of the nearby matrix.
    mean(nearby)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We apply this function to a plate, to count the mean number of well that have at
least one well contaminated.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;count_nearby_conta_well &amp;lt;- function(plate) {
    locate_conta_well &amp;lt;- function(plate) {
        which(plate != 0, arr.ind = TRUE)
    }

    ## stores the positions of contaminated wells inside a list of the form
    ## ( (row . column)
    ##   (row . column) )
    well_list &amp;lt;- locate_conta_well(plate)

    mean(
        apply(well_list, 1,
              function(x) {
            has_nearby_conta(plate, line = x[1], column = x[2])
        }))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;During the debugging of this function, it was particulary useful to have clean
and expressive names to decrypt the &lt;code&gt;traceback()&lt;/code&gt; output.&lt;/p&gt;

&lt;p&gt;We need to count the number of contaminated well inside our plate.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;count_conta &amp;lt;- function(plate) length(which(plate != 0))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s set &lt;em&gt;N&lt;/em&gt; the number of plate in the monte carlo simulation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;n_plate &amp;lt;- 1000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then generate 1000 plates with &lt;em&gt;C&lt;/em&gt; contamination inside of it,
randomly distributed on the plate.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# generate `n_plate` with C contaminated well
random_weak &amp;lt;- n_plate_generate(n_plate, 35)
## count the average number of nearby contaminated well per well and average it
## over the plate. Do it to all the plate in random_weak.
random_weak_mean_list &amp;lt;- lapply(random_weak, count_nearby_conta_well)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just so that you can see the data :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;head(random_weak, n = 3)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [[1]]
##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
## [1,]    1    1    0    0    0    1    1    1    0     0     0     0
## [2,]    1    0    1    0    1    1    0    1    0     0     1     0
## [3,]    0    0    0    0    0    1    1    1    1     0     0     1
## [4,]    1    1    0    0    0    0    0    0    1     0     0     0
## [5,]    1    0    0    1    0    1    1    0    1     0     0     0
## [6,]    0    0    1    0    0    1    0    0    0     0     1     1
## [7,]    0    0    0    0    0    1    0    1    0     0     1     0
## [8,]    0    1    0    1    1    0    0    0    1     0     0     0
## 
## [[2]]
##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
## [1,]    1    0    0    0    0    0    1    1    1     0     1     0
## [2,]    1    0    0    0    0    1    0    0    0     0     1     1
## [3,]    0    1    1    0    0    0    0    1    0     1     0     1
## [4,]    0    1    1    0    0    0    1    0    0     0     1     0
## [5,]    0    1    0    0    1    1    0    1    0     1     1     0
## [6,]    0    1    1    0    1    0    0    0    0     0     0     0
## [7,]    0    0    0    0    1    1    1    1    0     1     0     1
## [8,]    1    0    0    0    0    0    0    0    0     1     0     0
## 
## [[3]]
##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
## [1,]    0    0    0    1    1    0    0    0    0     0     0     1
## [2,]    0    0    1    0    1    1    1    0    0     1     0     1
## [3,]    0    1    0    0    1    0    0    0    0     1     1     1
## [4,]    0    0    0    0    1    1    0    1    0     1     1     0
## [5,]    1    0    0    0    1    0    0    0    1     0     0     0
## [6,]    0    0    0    1    0    0    0    1    0     0     0     1
## [7,]    0    0    0    0    1    0    0    1    0     0     1     0
## [8,]    1    1    1    0    1    1    0    0    1     0     1     0
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;head(random_weak_mean_list, n = 3)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [[1]]
## [1] 0.3440476
## 
## [[2]]
## [1] 0.3188095
## 
## [[3]]
## [1] 0.3590476
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the first plate, the 96 wells have a mean of  0.3440476
wells contaminated.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;plot_mean_distrib &amp;lt;- function(random_mean_list) {

    random_mean_list %&amp;gt;%
        unlist() %&amp;gt;%
        data.frame(wellcount = .) %&amp;gt;%
        ggplot(aes(wellcount)) +
        geom_histogram(binwidth = 0.005, fill = &amp;quot;gray&amp;quot;) +
        labs(x = &amp;quot;Mean number of nearby contaminated well per well per plate&amp;quot;) +
        theme_minimal() +
        theme(panel.ontop = TRUE,
              panel.grid.major.y =
                  element_line(colour = &amp;quot;white&amp;quot;, size = 0.5, linetype = &amp;quot;dotted&amp;quot;),
              panel.grid.minor.y =
                  element_line(colour = &amp;quot;white&amp;quot;, size = 0.5, linetype = &amp;quot;dotted&amp;quot;))

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A first plot :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;plot_mean_distrib(random_weak_mean_list)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://sam217pa.github.io/images/2016-07-05-randomweakmean-1.png&#34; alt=&#34;plot of chunk 2016-07-05-randomweakmean&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;factorial-in-r:6a5bf84d7e413edf98f3db000dff6cf1&#34;&gt;Factorial in R :&lt;/h1&gt;

&lt;p&gt;I think this function is the cleanest and fastest way to express the factorial
function in R. And yes, &lt;code&gt;*&lt;/code&gt; is a function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;factorial &amp;lt;- function(n) {
    Reduce(f = `*`, x = 1:n, init = 1)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:6a5bf84d7e413edf98f3db000dff6cf1:Actually-it-is-t&#34;&gt;Actually it is the language I am the most comfortable with, so it is not really a good comparisonâ€¦ &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:6a5bf84d7e413edf98f3db000dff6cf1:Actually-it-is-t&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>War of the languages</title>
      <link>http://sam217pa.github.io/2016/06/30/war-of-the-languages/</link>
      <pubDate>Thu, 30 Jun 2016 12:52:33 +0200</pubDate>
      
      <guid>http://sam217pa.github.io/2016/06/30/war-of-the-languages/</guid>
      <description>

&lt;h1 id=&#34;chosing-a-language:0e364b36ad4d8508a9d862aa1493b4bd&#34;&gt;Chosing a language&lt;/h1&gt;

&lt;p&gt;I&amp;rsquo;ve been trying to make up my mind about which programming languages I should
know. I&amp;rsquo;ve come to the conclusion that I must know what matters to me. That&amp;rsquo;s
not a very exciting conclusion.&lt;/p&gt;

&lt;p&gt;But when you&amp;rsquo;re starting off in a new field, you are very curious about chosing
the right tool for the job. You wander around on the internet, read some pros
and cons of some particular language, start to learn about it, read some more
pros and cons, switch to a new language, repeat.&lt;/p&gt;

&lt;p&gt;When I began to learn some data science tools on
&lt;a href=&#34;https://www.coursera.org/specializations/jhu-data-science&#34;&gt;Coursera&lt;/a&gt; two years
ago, I did not know which language to pick. They introduced &lt;code&gt;R&lt;/code&gt;, so I sticked
with &lt;code&gt;R&lt;/code&gt;. And I came to love it. I learned about the most useful packages and
all that. Learned some graphics techniques too&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:0e364b36ad4d8508a9d862aa1493b4bd:ggplot2-to-the-r&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:0e364b36ad4d8508a9d862aa1493b4bd:ggplot2-to-the-r&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. This
time was great. I was not comparing &lt;code&gt;R&lt;/code&gt; to other languages. I knew only about
&lt;code&gt;R&lt;/code&gt;. I was not saying &amp;ldquo;Oh, I wish &lt;code&gt;R&lt;/code&gt; could do that!&amp;rdquo; or &amp;ldquo;If only &lt;code&gt;R&lt;/code&gt; was as
clean as &lt;code&gt;Python&lt;/code&gt;&amp;rdquo;. I sticked to &lt;code&gt;R&lt;/code&gt;, and learned a ton. It reminds me of the
period of life where people usually learn the most : childhood. Just thinking
about the mass of information we have to face as a baby is incredible. The
process of learning a first programming language is really similar. We have to
face many information simultaneously : what is a for
loop&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:0e364b36ad4d8508a9d862aa1493b4bd:Not-in-R-of-cour&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:0e364b36ad4d8508a9d862aa1493b4bd:Not-in-R-of-cour&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;, what is a terminal, what is an IDE, what is a
function, where are my data, how do I learn about X, what was the name of this
function already, I wish I knew of a function that could do this and that, what
is the name of these functions&amp;rsquo; arguments, â€¦&lt;/p&gt;

&lt;p&gt;And then, when I was getting familiar with common hacking techniques, I grew
curious about what was on the other side. Maybe Python is cool too. I checked
Python. What ? No &lt;code&gt;library(foo)&lt;/code&gt; ? Python3 is so different from Python2 that I
have to use a &lt;code&gt;virtualenv&lt;/code&gt; ? What is a &lt;code&gt;virtualenv&lt;/code&gt; ? How do I set up all this ?
&lt;code&gt;R&lt;/code&gt; was so much simpler. I guess there is other languages that are closer to &lt;code&gt;R&lt;/code&gt;
and simpler to use than python. Well, &lt;code&gt;julia&lt;/code&gt; is. Let&amp;rsquo;s learn some &lt;code&gt;julia&lt;/code&gt;. Oh
but wait, &lt;code&gt;julia&lt;/code&gt; is only 0.3.2. I cannot use &lt;code&gt;julia&lt;/code&gt; for now. Nobody knows
it. But hey, I learned about speed of executions. I now know that R is
slow. Maybe I can learn a compiled language like C ? Maybe it would be a good
idea to know what the community think about a good first language to pick ? (Go
on stackoverflow). Ok, what ? Structure and Interpretation of Computer Programs
? This is the second time I hear this name. I know Hadley suggests it as a good
introduction to functional programming in &lt;code&gt;R&lt;/code&gt;. Let&amp;rsquo;s read it. &lt;code&gt;Scheme&lt;/code&gt; ?
Parenthesis everywhere. Simple syntax. Lego for the mind. Ok then let&amp;rsquo;s learn
Scheme. But Scheme is nowhere to be seen in a production environment. What the â€¦
is a production environment ? Maybe let&amp;rsquo;s learn some Clojure then. Ok so I need
to learn about the JVM ? Clojure is functional programming on the JVM, like
Scala. Scala ? Syntax similar to &lt;code&gt;R&lt;/code&gt;, good constructs and all. But Scala is so
java like that you have to use a dedicated IDE. And I love emacs. Well then not
Scala. Maybe Clojure ? But wait.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What&amp;rsquo;s the point ?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;what-do-i-need-from-a-programming-language:0e364b36ad4d8508a9d862aa1493b4bd&#34;&gt;What do I need from a programming language ?&lt;/h1&gt;

&lt;p&gt;I need it to be simple to use. I do not want to be a software engineer. I want
to be able to analyse data. I want to be able to look at a biological data set,
and get meanings from it. I do not need to know about GUI or stuff like
that. Maybe &lt;code&gt;R&lt;/code&gt; was a good choice after all. Maybe I could check out what is the
most used language in my field ? Ok then it&amp;rsquo;s &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;Python&lt;/code&gt;. Well, let&amp;rsquo;s
stick to &lt;code&gt;R&lt;/code&gt;, and learn some &lt;code&gt;Python&lt;/code&gt; to wrangle some sequences.&lt;/p&gt;

&lt;p&gt;Now I&amp;rsquo;m glad I did all that. It took me a year or so. But now I know why I am at
my computer. I learned some pretty amazing stuff. But now I can focus on what is
important to me as a data scientist : I want an analysis environment that is
simple to use, closer to the data than to the metal, in which I can quickly
abstract ideas&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:0e364b36ad4d8508a9d862aa1493b4bd:functional-progr&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:0e364b36ad4d8508a9d862aa1493b4bd:functional-progr&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;, and if
needed, that I can make faster easily&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:0e364b36ad4d8508a9d862aa1493b4bd:looking-at-you-R&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:0e364b36ad4d8508a9d862aa1493b4bd:looking-at-you-R&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;R&lt;/code&gt; is all that. You can interface it with C++ seamlessly with dedicated
package, to make it really really fast. Yet you can stay in your REPL all along,
never worrying about the implementations details, never worrying about where
your class is defined, what was the button of that IDE that did this, where was
the button of that other IDE that did that, which software version am I using,
if I develop some code, will it be easy to deploy to another computer, not using
macOS like me ? &lt;code&gt;R&lt;/code&gt; is a great environment in this regard. It abstracts many
things from the data analyst, and make his life really easy.&lt;/p&gt;

&lt;h1 id=&#34;use-r-learn-python-learn-c:0e364b36ad4d8508a9d862aa1493b4bd&#34;&gt;Use R. Learn Python. Learn C++&lt;/h1&gt;

&lt;p&gt;As a final advice to anybody reading this, which like me, is trying to find his
place in this world of software engineers and bioinformatician. You don&amp;rsquo;t want
to be a software engineer. You want to analyse data. This is not your job to
build up the algorithm of that particular piece of software, or the details of
the implementation of a particular class or object. You want to know what is
this gene doing. You want to know why this bacteria is always associated with
this particular plant. You want to know why it is that a bacteria can be composed
of 13% of GC, and another of 76%. There is some data associated with it.&lt;/p&gt;

&lt;p&gt;Use python to make your data available to R. Python is very good at wrangling
data, like perl was in its glory days. When the data is in R, use the right tool
for the job. If a function is slow, try another approach. Try to vectorize
it. Try to make it simpler. Use optimized functions. When it&amp;rsquo;s still slow, use
C++. Those are the three tools one need to turn most analysis from an idea to a
reality.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:0e364b36ad4d8508a9d862aa1493b4bd:ggplot2-to-the-r&#34;&gt;&lt;code&gt;ggplot2&lt;/code&gt; to the rescue ! &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:0e364b36ad4d8508a9d862aa1493b4bd:ggplot2-to-the-r&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:0e364b36ad4d8508a9d862aa1493b4bd:Not-in-R-of-cour&#34;&gt;Not in &lt;code&gt;R&lt;/code&gt; of course ;) &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:0e364b36ad4d8508a9d862aa1493b4bd:Not-in-R-of-cour&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:0e364b36ad4d8508a9d862aa1493b4bd:functional-progr&#34;&gt;functional programming was a good idea after allâ€¦ &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:0e364b36ad4d8508a9d862aa1493b4bd:functional-progr&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:0e364b36ad4d8508a9d862aa1493b4bd:looking-at-you-R&#34;&gt;looking at you Rcpp and Cython &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:0e364b36ad4d8508a9d862aa1493b4bd:looking-at-you-R&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Using LaTeX</title>
      <link>http://sam217pa.github.io/2016/06/07/using-latex/</link>
      <pubDate>Tue, 07 Jun 2016 14:33:06 +0200</pubDate>
      
      <guid>http://sam217pa.github.io/2016/06/07/using-latex/</guid>
      <description>&lt;p&gt;LaTeX is a great tool.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve recently used it to write my master&amp;rsquo;s memoir (accessible
&lt;a href=&#34;https://www.dropbox.com/s/6btccuw8hudxvgo/rapport.pdf?dl=0&#34;&gt;here&lt;/a&gt;). I used Tikz
to draw simple diagrams. They are really simple, yet I do not know of any other
tool that I could use to produce these diagrams. In their first implementation,
those diagrams integrated rather tightly text and figures. I said it before, and
I say it again : I am firmly convinced that Tufte is right about integrating
visual evidence with text. The Old Masters like &lt;em&gt;da Vinci&lt;/em&gt; and &lt;em&gt;Galileo&lt;/em&gt; did it.
That was normal at the time: text was written with the support of visual
evidence. They used ink.&lt;/p&gt;

&lt;p&gt;We use computers. That makes the idea of laying down text and visual evidence
together more difficult. We are used to separate it. One page for text, one page
for figures. Sometimes the text describes something that is not even seeable by
the reader, because the corresponding figure is on the next page.&lt;/p&gt;

&lt;p&gt;LaTeX and Tikz allow us to do that much more naturally. It really is simple to
integrate text, maths, figures, drawing, photos and diagrams together. Plus it
is free. It is really moldable, you can lead LaTeX to draw anything you want.
Search on Google, you will see some great examples of Phd Thesis written in
LaTeX with great figures and diagrams. Nobody can do it inside Microsoft Word.
Maybe it could be done inside Adobe InDesign, but I have no experience with it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sam217pa.github.io/images/recombinaison.png&#34; alt=&#34;Homologous Recombination During Natural Transformation&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Migrating to Hugo</title>
      <link>http://sam217pa.github.io/2016/06/06/switch-to-hugo/</link>
      <pubDate>Mon, 06 Jun 2016 20:08:11 +0200</pubDate>
      
      <guid>http://sam217pa.github.io/2016/06/06/switch-to-hugo/</guid>
      <description>

&lt;p&gt;I quit Jekyll today. Not a really huge decision to make, the blog is really
small at this point. I could convert all metadata and all by hand. That was
before I knew that Hugo has some tools to ease the switch.&lt;/p&gt;

&lt;h1 id=&#34;so-long-jekyll:379062a983a2c96623df21277397b505&#34;&gt;So long Jekyll&lt;/h1&gt;

&lt;p&gt;I got tired of Jekyll for two reasons. The first is that I had a lot of stuff to
install before being able to serve and test my website. The second is that it is
a hell to maintain a blog with it. The last post I wrote
(&lt;a href=&#34;http://sam217pa.github.io/2016/02/06/2016-02-06-emacs-in-my-toolbox/&#34;&gt;here&lt;/a&gt;)
was published with Jekyll. That was before I upgraded to El Capitan. All hell
went lose after that. Some dependencies were upgraded too, and stuff I&amp;rsquo;ve done
four months ago were to be done again. I don&amp;rsquo;t have a clue about the &lt;code&gt;Ruby&lt;/code&gt;
ecosystem, and I&amp;rsquo;m not particularly interested in learning it. I know it is
really simple, but I don&amp;rsquo;t have the time nor the motivation to.&lt;/p&gt;

&lt;h1 id=&#34;hi-hugo:379062a983a2c96623df21277397b505&#34;&gt;Hi Hugo&lt;/h1&gt;

&lt;p&gt;I chosed Hugo for two reasons. The first is that I had great experiences with
tools written in &lt;code&gt;Go&lt;/code&gt; recently, mainly &lt;a href=&#34;https://github.com/junegunn/fzf&#34;&gt;fzf&lt;/a&gt;
and &lt;a href=&#34;https://github.com/monochromegane/the_platinum_searcher&#34;&gt;pt&lt;/a&gt;. I had taken a
look at &lt;a href=&#34;https://github.com/urfave/cli&#34;&gt;cli&lt;/a&gt; when I was looking for a simple way
to write a command line app&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:379062a983a2c96623df21277397b505:I-ended-up-using&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:379062a983a2c96623df21277397b505:I-ended-up-using&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;, and it looked dead simple. &lt;code&gt;Go&lt;/code&gt;-based tools seems to have a &amp;ldquo;keep it
simple stupid&amp;rdquo; spirit that appeals to me very much. The second reason is that
Hugo has an awesome &lt;a href=&#34;https://gohugo.io/&#34;&gt;website&lt;/a&gt; and
&lt;a href=&#34;https://gohugo.io/overview/introduction/&#34;&gt;documentation&lt;/a&gt; that makes it really
easy to have a quick overview of what it can do.&lt;/p&gt;

&lt;p&gt;Since I don&amp;rsquo;t need really complex stuff to be done in a simple blog, I thought
Hugo was a great choice. Its speed was the icing on the cake. I tend to think
that I don&amp;rsquo;t need it. But when you have it, you don&amp;rsquo;t look back. Same goes for
&lt;code&gt;ag&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To deploy the website to GitHub Pages, simply &lt;code&gt;git init&lt;/code&gt; in the &lt;code&gt;public&lt;/code&gt;
directory, and &lt;code&gt;git remote add&lt;/code&gt; your repo URL. GitHub Pages are generated at
super speed. This is really simple.&lt;/p&gt;

&lt;p&gt;I would definitely recommend Hugo to anybody wanting to start a blog. I find it
really simple to use, much more than Jekyll. And it has great themes.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:379062a983a2c96623df21277397b505:I-ended-up-using&#34;&gt;I ended up using &lt;a href=&#34;http://click.pocoo.org/5/&#34;&gt;click&lt;/a&gt; with Python. Great library, although it tends to introduce some clumsiness in the app &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:379062a983a2c96623df21277397b505:I-ended-up-using&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Changing my Emacs Paradigm</title>
      <link>http://sam217pa.github.io/2016/06/06/emacs-changing-paradigm/</link>
      <pubDate>Mon, 06 Jun 2016 19:47:05 +0200</pubDate>
      
      <guid>http://sam217pa.github.io/2016/06/06/emacs-changing-paradigm/</guid>
      <description>

&lt;p&gt;In my previous
&lt;a href=&#34;http://sam217pa.github.io/2016/02/06/2016-02-06-emacs-in-my-toolbox/&#34;&gt;post&lt;/a&gt;, I
talked about the way I tended to integrate everything in Emacs. In this one, I
want to describe what lead me to totally change the way I use it.&lt;/p&gt;

&lt;h1 id=&#34;living-in-the-terminal:90f8f993beffe30febe8d9a4af8da2db&#34;&gt;Living in the terminal&lt;/h1&gt;

&lt;p&gt;I just spend four months in front of my computer. I literally lived inside my
terminal for various reasons. I had biological data to analyse, and software to
develop to do it. I used &lt;code&gt;R&lt;/code&gt;, &lt;code&gt;bash&lt;/code&gt;, &lt;code&gt;perl&lt;/code&gt; and &lt;code&gt;Python&lt;/code&gt; and read some &lt;code&gt;C&lt;/code&gt; code
too. The diversity of languages we have to face when working in the
bioinformatics field is incredible. For that I was lucky to have chosen to learn
polyglot &lt;code&gt;vi&lt;/code&gt; and &lt;code&gt;emacs&lt;/code&gt; in the past. Not being locked to a particuliar IDE
when facing that much diversity is a great thing.&lt;/p&gt;

&lt;h1 id=&#34;developping-inside-emacs:90f8f993beffe30febe8d9a4af8da2db&#34;&gt;Developping inside emacs&lt;/h1&gt;

&lt;p&gt;At the beginning, I was doing exactly what I described in my previous post. I
lived inside org-mode, using code blocks to put up software and describe what
each piece of code was doing. I then tangled each block to its file, tested it,
went back to org-mode, debugged it, tangled it, tested it â€¦ At the end of the
day, that makes a lot of &lt;code&gt;C-u C-u C-c C-v
t&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:90f8f993beffe30febe8d9a4af8da2db:org-babel-tangle&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:90f8f993beffe30febe8d9a4af8da2db:org-babel-tangle&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;I had to speed up the way I wrote software, particularly when I was facing very
tight deadlines. I really gradually started not to use org-mode to organise
source code. Then I was not using it at all. Even my TODO notes migrated to
&lt;a href=&#34;https://taskwarrior.org/&#34;&gt;taskwarrior&lt;/a&gt;, a great command line tool with very
similar abilities as org-mode. The only benefit it has is being accessible from
the command line really fast. Just type &lt;code&gt;alias T=&#39;task&#39;&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; to have a brief
overview of what&amp;rsquo;s to be done.&lt;/p&gt;

&lt;p&gt;Then I (re)learned to use &lt;a href=&#34;https://tmux.github.io/&#34;&gt;tmux&lt;/a&gt;, and started to
harness the emacs daemon feature. It boosted my productivity a great deal. Just
add&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;export EDITOR=&amp;quot;emacsclient -t&amp;quot;
export ALTERNATE_EDITOR=&amp;quot;&amp;quot;

alias e=&#39;emacsclient -t&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to your &lt;code&gt;.bashrc&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:90f8f993beffe30febe8d9a4af8da2db:or-zshrc-you-sho&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:90f8f993beffe30febe8d9a4af8da2db:or-zshrc-you-sho&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;, and you&amp;rsquo;re all
set to use emacs as your main editor. You can have as many tmux sessions you
want, there is only one emacs instance to edit all the file you edit. It makes
integrating emacs and the typical terminal environment, with all its speed and
comfort, really nicer.&lt;/p&gt;

&lt;p&gt;I recommend it to everyone searching for a way to integrate emacs within its
terminal. I remember being very destabilized when I quit vim to emacs by the
fact that emacs was really slow to open a simple file. I ended up using only the
graphical emacs, but had to switch between emacs and the terminal quite often.
To be honest, the &lt;code&gt;shell&lt;/code&gt;, &lt;code&gt;ansiterm&lt;/code&gt;, &lt;code&gt;eshell&lt;/code&gt; and all are not that great for
now inside emacs. It feels very clumsy and slow, and result in all sort of bugs
when emacs tries to syntax highlight everything.&lt;/p&gt;

&lt;p&gt;I mapped &lt;code&gt;server-edit&lt;/code&gt; to &lt;code&gt;SPC-.&lt;/code&gt; inside Spacemacs, so that I can quickly switch
between emacs and the terminal environment.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:90f8f993beffe30febe8d9a4af8da2db:org-babel-tangle&#34;&gt;&lt;code&gt;org-babel-tangle&lt;/code&gt;, when given two prefix arguments, tangles only the block that correponds to the same output file. This function is really great.  &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:90f8f993beffe30febe8d9a4af8da2db:org-babel-tangle&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:90f8f993beffe30febe8d9a4af8da2db:or-zshrc-you-sho&#34;&gt;or &lt;code&gt;.zshrc&lt;/code&gt;, you should obviously use zsh. &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:90f8f993beffe30febe8d9a4af8da2db:or-zshrc-you-sho&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Emacs in My Toolbox</title>
      <link>http://sam217pa.github.io/2016/02/06/2016-02-06-emacs-in-my-toolbox/</link>
      <pubDate>Sat, 06 Feb 2016 15:42:58 +0100</pubDate>
      
      <guid>http://sam217pa.github.io/2016/02/06/2016-02-06-emacs-in-my-toolbox/</guid>
      <description>

&lt;p&gt;Emacs is a powerful tool. A frequent habit of emacs user is to try to migrate
everything they know and use inside emacs. Emacs Gnus or mu4e, both emacs mail
clients, emacs org-mode, a GTD mode inside emacsâ€”which is actually extremely
powerfulâ€”, emacs calc, a calculator inside emacs etcâ€¦ are all attempts in this
line of conduct.&lt;/p&gt;

&lt;p&gt;As an emacs user myself, I also tried these stuff. And it works really well.&lt;/p&gt;

&lt;p&gt;As a matter of fact, I actually use it all day long. Let&amp;rsquo;s describe quickly how
I use it to work.&lt;/p&gt;

&lt;h1 id=&#34;emacs-matters:345c4f196a8df77a0db582cec8160fba&#34;&gt;Emacs Matters&lt;/h1&gt;

&lt;p&gt;I start emacs as I start my OS. I used to check mails with mu4e, but never
really loved the UI. I check my agenda for the day, built with org-mode. I set
up my main tasks for the day, putting some time-stamps on it.&lt;/p&gt;

&lt;h1 id=&#34;programming-and-documenting-at-the-same-time:345c4f196a8df77a0db582cec8160fba&#34;&gt;Programming and documenting. At the same time.&lt;/h1&gt;

&lt;p&gt;I then open the README.org of the project I&amp;rsquo;m currently working on, which
involves a lot of bash scripting, python and R. All these scripts are written
inside the README.org, with comments and all written in org-mode. Scripts are
written inside &lt;code&gt;src&lt;/code&gt; blocks, and tangled to a src directory containing all my
tangled files. I never ever edit a single tangled files. I always do it inside
org-mode, so that I can describe my work, what I try to do, what I already did
and what&amp;rsquo;s left to do at the end of the day. My workflow is thus entirely
managed inside emacs. I can put TODO flags in different parts of the project,
organise the src code in different header tree etcâ€¦&lt;/p&gt;

&lt;h1 id=&#34;org-mode-to-pdf:345c4f196a8df77a0db582cec8160fba&#34;&gt;Org-mode to pdf&lt;/h1&gt;

&lt;p&gt;When the time comes to write a report, I write it inside org-mode. I use zotero
to export my references to a &lt;code&gt;.bib&lt;/code&gt; file somewhere on my computer. Org-ref is a
mode to manage citations and references inside org-mode. I already wrote a 30
pages long report with figures, references, math and all inside org-mode. I
export to latex, and use &lt;code&gt;latexmk&lt;/code&gt; to export my report to pdf.&lt;/p&gt;

&lt;p&gt;Emacs is great. Let&amp;rsquo;s all use emacs.
&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:345c4f196a8df77a0db582cec8160fba:I-actually-use-S&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:345c4f196a8df77a0db582cec8160fba:I-actually-use-S&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:345c4f196a8df77a0db582cec8160fba:I-actually-use-S&#34;&gt;I actually use Spacemacs, a combination of Vim and Emacs. It&amp;rsquo;s great if you plan to stay all day at the computer : your pinky will thank you for that. It&amp;rsquo;s all the more true if you have it broken like me ! &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:345c4f196a8df77a0db582cec8160fba:I-actually-use-S&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Lectures and Data Visualization</title>
      <link>http://sam217pa.github.io/2015/10/21/2015-10-21-lectures-and-datavis/</link>
      <pubDate>Wed, 21 Oct 2015 20:40:26 +0200</pubDate>
      
      <guid>http://sam217pa.github.io/2015/10/21/2015-10-21-lectures-and-datavis/</guid>
      <description>

&lt;p&gt;Powerpoints are everywhere. In our world of science, Powerpoints are the &lt;em&gt;lingua
franca&lt;/em&gt; of lectures. Yet they are seldom used to their rightful potential. I
believe Powerpoints are often accused of the lecturer&amp;rsquo;s fault. I speak here with
the legitimacy of a student that spent most of the last six years listening to
lecturers with poor lecturing skills&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:155e6c1f545572b1746defd0cf82a1c5:I-am-not-saying&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:155e6c1f545572b1746defd0cf82a1c5:I-am-not-saying&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;I am a great admirer of Edward Tufte&amp;rsquo;s work about data visualization. Yet I
disagree with his opinion that Powerpoints kills reasoning. Actually I believe
there are many overlaps between good data visualization and good lectures.&lt;/p&gt;

&lt;p&gt;Here are Tufte&amp;rsquo;s opinion on graphical excellence. Good graphics :&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;show the data&lt;/li&gt;
&lt;li&gt;induce the viewer to think about substance rather than methodology, design
or something else.&lt;/li&gt;
&lt;li&gt;avoid distorting the data.&lt;/li&gt;
&lt;li&gt;present many number in a small space.&lt;/li&gt;
&lt;li&gt;make large data sets coherent.&lt;/li&gt;
&lt;li&gt;reveal the data at several levels of details, from a broad overview to a
fine structure.&lt;/li&gt;
&lt;li&gt;serve a clear purpose.&lt;/li&gt;
&lt;li&gt;be closely integrated with the statistical and verbal description of the
data.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;As a matter of fact, a good lectures shares the same objectives. Good lectures :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;show the question.&lt;/li&gt;
&lt;li&gt;induce the listener to think about substance rather than the lecturer&amp;rsquo;s style of lecturing.&lt;/li&gt;
&lt;li&gt;avoid distorting the question&lt;/li&gt;
&lt;li&gt;present many complex facts and ideas in a small space.&lt;/li&gt;
&lt;li&gt;make complex, multivariate questions coherent.&lt;/li&gt;
&lt;li&gt;reveals the ins and outs of the question at several levels of details, from a
broad overview to the finest technical details.&lt;/li&gt;
&lt;li&gt;serve a clear purpose.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here I&amp;rsquo;ll expose what I think makes a good
lecturer&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:155e6c1f545572b1746defd0cf82a1c5:I-ll-talk-indiff&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:155e6c1f545572b1746defd0cf82a1c5:I-ll-talk-indiff&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;.
It follows Tufte&amp;rsquo;s ideas on data visualization.&lt;/p&gt;

&lt;h2 id=&#34;good-lecturers-show-the-question:155e6c1f545572b1746defd0cf82a1c5&#34;&gt;Good lecturers show the question&lt;/h2&gt;

&lt;p&gt;A Powerpoint and a lecturer are useless if the scientific question behind it is
not understood by the audience.&lt;/p&gt;

&lt;p&gt;A good Powerpoint should always have a clear title. It describes clearly and
concisely the broad topic. It serves its goal even better as a question.
Questions gives direction to reasoning.&lt;/p&gt;

&lt;h2 id=&#34;good-lecturers-have-a-good-style:155e6c1f545572b1746defd0cf82a1c5&#34;&gt;Good lecturers have a good style.&lt;/h2&gt;

&lt;p&gt;This is my main point. Good lecturers induces the listener to think about the
&lt;em&gt;question&lt;/em&gt;. The listener should not have to think about the lecture&amp;rsquo;s style. To
paraphrase Pr HervÃ© Maisonneuve :&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Good style is absence of style.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Color that serves no goal should disappear. Forget Powerpoints ready-made
templates. They have no place in Science. Superfluous words should disappear.
Diagrams are clear. They take the space they need, no more.&lt;/p&gt;

&lt;p&gt;Indeed, I do agree with Edward Tufte that Powerpoints should be reserved for
pictures, diagrams and charts. In Science, we can put all aspects of reasoning
to good use. Some people needs a visual support to information. But the
excessive use of Powerpoints has shifted this support from the lecturer to the
screen. We need to realize this. The support of information is the lecturer. The
audience should be &lt;em&gt;listening&lt;/em&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:155e6c1f545572b1746defd0cf82a1c5:Listening-is-a-s&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:155e6c1f545572b1746defd0cf82a1c5:Listening-is-a-s&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;. Not staring at a screen,
trying to make sense of verbless sentences.&lt;/p&gt;

&lt;p&gt;Poor lecturers tend to put too much textual information on screen. As if they
were hoping that it could rescue their audience&amp;rsquo;s lack of attentionâ€¦&lt;/p&gt;

&lt;p&gt;As does good charts, good lecturers are neutral enough to shift focus from form
to content.&lt;/p&gt;

&lt;h2 id=&#34;good-lecturers-do-not-distort-the-question:155e6c1f545572b1746defd0cf82a1c5&#34;&gt;Good lecturers do not distort the question.&lt;/h2&gt;

&lt;p&gt;Good lecturers do not leave an opinionated point of view of the question in the
listener&amp;rsquo;s mind. On the contrary, they should be subtle enough to put the seeds
of good reasoning in it. The listener has the choice to make it flourish.&lt;/p&gt;

&lt;h2 id=&#34;good-lecturers-synthesize:155e6c1f545572b1746defd0cf82a1c5&#34;&gt;Good lecturers synthesize.&lt;/h2&gt;

&lt;p&gt;Good lecturers show many elements to the listener. They give him keys to analyze
those elements. Or they can lead him to get this keys by
himself&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:155e6c1f545572b1746defd0cf82a1c5:It-depends-on-th&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:155e6c1f545572b1746defd0cf82a1c5:It-depends-on-th&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;But they have to be synthetic. One cannot hope to give a sufficiently broad
overview of a complex topic with too much divergence from the central point.&lt;/p&gt;

&lt;h2 id=&#34;good-lecturers-show-complexity:155e6c1f545572b1746defd0cf82a1c5&#34;&gt;Good lecturers show complexity.&lt;/h2&gt;

&lt;p&gt;Good lecturers connect facts between them. Good lecturers connect theories
between them. They connect theories to facts. They connect facts to theories.
They connect it to the audience&amp;rsquo;s knowledge. One can not be a good lecturer
without knowing his audience.&lt;/p&gt;

&lt;p&gt;A good lecturer&amp;rsquo;s main role is to make complex questions coherent.&lt;/p&gt;

&lt;h2 id=&#34;good-lecturers-show-details-and-perspective:155e6c1f545572b1746defd0cf82a1c5&#34;&gt;Good lecturers show details and perspective&lt;/h2&gt;

&lt;p&gt;A good lecturer has the ability to attach the finest details to the broader
tendency in which they are included. He knows the broad phenomena as well as
little peculiar details.&lt;/p&gt;

&lt;h2 id=&#34;good-lecturers-serves-a-clear-purpose:155e6c1f545572b1746defd0cf82a1c5&#34;&gt;Good lecturers serves a clear purpose.&lt;/h2&gt;

&lt;p&gt;It could be the #1 point. Good lecturers put things in context. Period. One can
never have the listener&amp;rsquo;s attention if the listener does not know why he should
listen. What is the point of this ? Why are you doing this ? Why work on this ?
To what point ?&lt;/p&gt;

&lt;p&gt;Such questions are so common that a lecturer tends to forget to answer it.&lt;/p&gt;

&lt;h1 id=&#34;conclusion:155e6c1f545572b1746defd0cf82a1c5&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;Tufte says a chart&amp;rsquo;s data to ink ratio should be maximized. Chartjunk should be
eliminated.&lt;/p&gt;

&lt;p&gt;I say ideas to speak ratio is the measure of a lecture&amp;rsquo;s quality. Talkjunk is
needless. So many talk are crippled with useless information that it is rather
the rule than the exception.&lt;/p&gt;

&lt;p&gt;Focus should be on the lecturer. Not on the screen. The lecturer&amp;rsquo;s focus should
be on the listener. Not on the screen.&lt;/p&gt;

&lt;p&gt;Powerpoints are a tool to assist reasoning. Not a support of information. Not a
decoration. They should be neutral. They should be the hammer of the lecturer. A
tool.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:155e6c1f545572b1746defd0cf82a1c5:I-am-not-saying&#34;&gt;I am not saying here that all of the lectures I had were of poor quality. I say most of them. &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:155e6c1f545572b1746defd0cf82a1c5:I-am-not-saying&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:155e6c1f545572b1746defd0cf82a1c5:I-ll-talk-indiff&#34;&gt;I&amp;rsquo;ll talk indifferently of lecturer or Powerpoint. To me, a Powerpoint is as bad as is its designer. &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:155e6c1f545572b1746defd0cf82a1c5:I-ll-talk-indiff&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:155e6c1f545572b1746defd0cf82a1c5:Listening-is-a-s&#34;&gt;Listening is a skill we have to re-learn. Powerpoints have made that much damage. &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:155e6c1f545572b1746defd0cf82a1c5:Listening-is-a-s&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:155e6c1f545572b1746defd0cf82a1c5:It-depends-on-th&#34;&gt;It depends on the lecturer&amp;rsquo;s style. Even though he should not have a style. Ha. &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:155e6c1f545572b1746defd0cf82a1c5:It-depends-on-th&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Embed D3 Code into a markdown Jekyll Document</title>
      <link>http://sam217pa.github.io/2015/10/20/2015-10-20-embed-d3-code/</link>
      <pubDate>Tue, 20 Oct 2015 00:33:53 +0200</pubDate>
      
      <guid>http://sam217pa.github.io/2015/10/20/2015-10-20-embed-d3-code/</guid>
      <description>&lt;p&gt;I deserve no credits for this. It is basically a copy and paste from Nick Such&amp;rsquo;s
previous &lt;a href=&#34;http://www.nicksuch.com/2014/03/26/d3-sample/&#34;&gt;post&lt;/a&gt;. It follows his
answer to a question on
&lt;a href=&#34;http://stackoverflow.com/questions/22651346/how-to-embed-a-d3-js-example-to-the-jekyll-blog-post&#34;&gt;StackOverflow&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;See
&lt;a href=&#34;https://raw.githubusercontent.com/nicksuch/nicksuch.github.io/master/_posts/2014-03-26-d3-sample.md&#34;&gt;here&lt;/a&gt;
for details about how to do it.&lt;/p&gt;

&lt;p&gt;&lt;style&gt;&lt;/p&gt;

&lt;p&gt;div.example {
  font-family: &amp;ldquo;Helvetica Neue&amp;rdquo;, Helvetica, Arial, sans-serif;
}&lt;/p&gt;

&lt;p&gt;.box {
  font: 10px sans-serif;
}&lt;/p&gt;

&lt;p&gt;.box line,
.box rect,
.box circle {
  fill: #008080;
  stroke: #000;
  stroke-width: 1.5px;
}&lt;/p&gt;

&lt;p&gt;.box .center {
  stroke-dasharray: 3,3;
}&lt;/p&gt;

&lt;p&gt;.box .outlier {
  fill: none;
  stroke: #ccc;
}&lt;/p&gt;

&lt;p&gt;&lt;/style&gt;
&lt;script src=&#34;http://d3js.org/d3.v3.min.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;http://bl.ocks.org/mbostock/raw/4061502/0a200ddf998aa75dfdb1ff32e16b680a15e5cb01/box.js&#34;&gt;&lt;/script&gt;
&lt;script&gt;&lt;/p&gt;

&lt;p&gt;var margin = {top: 10, right: 50, bottom: 20, left: 50},
    width = 120 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;&lt;/p&gt;

&lt;p&gt;var min = Infinity,
    max = -Infinity;&lt;/p&gt;

&lt;p&gt;var chart = d3.box()
    .whiskers(iqr(1.5))
    .width(width)
    .height(height);&lt;/p&gt;

&lt;p&gt;d3.csv(&amp;ldquo;/data/morley.csv&amp;rdquo;, function(error, csv) {
  var data = [];&lt;/p&gt;

&lt;p&gt;csv.forEach(function(x) {
    var e = Math.floor(x.Expt - 1),
        r = Math.floor(x.Run - 1),
        s = Math.floor(x.Speed),
        d = data[e];
    if (!d) d = data[e] = [s];
    else d.push(s);
    if (s &amp;gt; max) max = s;
    if (s &amp;lt; min) min = s;
  });&lt;/p&gt;

&lt;p&gt;chart.domain([min, max]);&lt;/p&gt;

&lt;p&gt;var svg = d3.select(&amp;ldquo;div#example&amp;rdquo;).selectAll(&amp;ldquo;svg&amp;rdquo;)
      .data(data)
    .enter().append(&amp;ldquo;svg&amp;rdquo;)
      .attr(&amp;ldquo;class&amp;rdquo;, &amp;ldquo;box&amp;rdquo;)
      .attr(&amp;ldquo;width&amp;rdquo;, width + margin.left + margin.right)
      .attr(&amp;ldquo;height&amp;rdquo;, height + margin.bottom + margin.top)
    .append(&amp;ldquo;g&amp;rdquo;)
      .attr(&amp;ldquo;transform&amp;rdquo;, &amp;ldquo;translate(&amp;rdquo; + margin.left + &amp;ldquo;,&amp;rdquo; + margin.top + &amp;ldquo;)&amp;rdquo;)
      .call(chart);&lt;/p&gt;

&lt;p&gt;setInterval(function() {
    svg.datum(randomize).call(chart.duration(1000));
  }, 2000);
});&lt;/p&gt;

&lt;p&gt;function randomize(d) {
  if (!d.randomizer) d.randomizer = randomizer(d);
  return d.map(d.randomizer);
}&lt;/p&gt;

&lt;p&gt;function randomizer(d) {
  var k = d3.max(d) * .02;
  return function(d) {
    return Math.max(min, Math.min(max, d + k * (Math.random() - .5)));
  };
}&lt;/p&gt;

&lt;p&gt;// Returns a function to compute the interquartile range.
function iqr(k) {
  return function(d, i) {
    var q1 = d.quartiles[0],
        q3 = d.quartiles[2],
        iqr = (q3 - q1) * k,
        i = -1,
        j = d.length;
    while (d[++i] &amp;lt; q1 - iqr);
    while (d[&amp;ndash;j] &amp;gt; q3 + iqr);
    return [i, j];
  };
}&lt;/p&gt;

&lt;p&gt;&lt;/script&gt;&lt;/p&gt;

&lt;div id=&#34;example&#34;&gt;&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Biased Gene Conversion</title>
      <link>http://sam217pa.github.io/2015/10/17/2015-10-17-biased-gene-conversion/</link>
      <pubDate>Sat, 17 Oct 2015 15:17:18 +0200</pubDate>
      
      <guid>http://sam217pa.github.io/2015/10/17/2015-10-17-biased-gene-conversion/</guid>
      <description>

&lt;p&gt;Base composition of genomes is affected by many major process, being either
neutral or selective. The neutral model describes mutations as following the
genetic drift, which depends on population effective size. It does not represent
the genome reality very well, but it is a useful model as a null hypothesis. One
must reject the neutral hypothesis before affirming that a genomic trait is under
selection constraints.&lt;/p&gt;

&lt;h1 id=&#34;natural-selection-hypothesis:b61b64bfc3b666379e845ac6ec86f6ab&#34;&gt;Natural Selection hypothesis&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;A curious aspect of the theory of evolution is that everybody thinks he
understands it. &lt;em&gt;Jacques Monod&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The natural selection hypothesis discriminate three cases of a genomic trait
being under selective constraints. The positive or directional selection leads
to the gradual erasing of variation on a given position of the genome, if this
position has a positive impact on the fitness. The purifying, or negative
selection, act against all variation, nearly all mutation are deleterious.
Typically, a mutation on conserved region of 16S rDNA in Bacteria are
deleterious : they does not spread in the population.&lt;/p&gt;

&lt;p&gt;Recently, a new process that can confound selection tracks with a neutral
process has been discovered : the biased gene conversion.&lt;/p&gt;

&lt;h1 id=&#34;gene-conversion:b61b64bfc3b666379e845ac6ec86f6ab&#34;&gt;Gene conversion&lt;/h1&gt;

&lt;p&gt;A gene conversion event takes place when the resolution of the intermediate
poroduct of homolog recombination leads to the
uni-directionalâ€”non-reciprocalâ€”exchange of genetic information from one donor to
a receptor sequence. It is a key process of the first meiosis division, an
obligate step in eukaryotes gametogenesis.&lt;/p&gt;

&lt;p&gt;Nevertheless, if one allele has a greater chance to be the donor, the process is
biased.&lt;/p&gt;

&lt;h1 id=&#34;biased-gene-conversion:b61b64bfc3b666379e845ac6ec86f6ab&#34;&gt;Biased Gene Conversion&lt;/h1&gt;

&lt;p&gt;There are two main scenarios to explain a biased gene conversion event.&lt;/p&gt;

&lt;h2 id=&#34;initiation-bias:b61b64bfc3b666379e845ac6ec86f6ab&#34;&gt;Initiation bias&lt;/h2&gt;

&lt;p&gt;The initiation bias appears when a region on one double stranded DNA is more
often victim of double strand breaks than its homolog region on the sister
chromosome. This region is thus called a recombination hotspots, whereas its
homolog on the sister chromosome is called a recombination coldspots.
Paradoxically, on the lifespan of the hotspot, the coldspot will more often be
the donor of gene conversion events, leading to the gradual death of the
corresponding hotspot. There is an initiation bias on the gene conversion event.&lt;/p&gt;

&lt;h2 id=&#34;gc-biased-gene-conversion:b61b64bfc3b666379e845ac6ec86f6ab&#34;&gt;GC-biased gene conversion&lt;/h2&gt;

&lt;p&gt;The other bias is called GC-bias gene conversion. Indeed, it has been shown in
many eukaryotes, including yeast and human, that the G or C alleles of a gene
are statistically significantly more often the donor of a gene conversion event
than its A or T corresponding allele.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;It looks exactly as directed selection, but is &lt;em&gt;not&lt;/em&gt; an adaptative process.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;One can find traces of GC-bias gene conversion in a region if all positions are
affected, being either neutral or &lt;em&gt;even deleterious&lt;/em&gt;. Typically, gBGC is
associated with regions of high rate of recombination, actual or past. While
selection only act on non neutral regions&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:b61b64bfc3b666379e845ac6ec86f6ab:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:b61b64bfc3b666379e845ac6ec86f6ab:3&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;, gBGC also acts on nearby introns
and non-functional sequences. Moreover, selection can act on a very large
genomic scale, when linkage is taken into account.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;gBGC has been shown to be responsible for the large scale variations of
GC-content, the so called genomic isochores; it can lead to the fixation of
deleterious mutations; and it can confound traces of selection.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:b61b64bfc3b666379e845ac6ec86f6ab:3&#34;&gt;exons or regulatory sequences
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:b61b64bfc3b666379e845ac6ec86f6ab:3&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Hill-Robertson Effects</title>
      <link>http://sam217pa.github.io/2015/10/15/2015-10-15-hill-robertson-effects/</link>
      <pubDate>Thu, 15 Oct 2015 19:06:40 +0200</pubDate>
      
      <guid>http://sam217pa.github.io/2015/10/15/2015-10-15-hill-robertson-effects/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;Hill-Robertson effects are interference between two locus under selection. When
recombination is weak, selection on the two locus interfere. Selection is less
efficient than when it acts on two independent locus.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Consider &lt;em&gt;A&lt;/em&gt; and &lt;em&gt;B&lt;/em&gt;, two moderately advantageous allele, in different
population. They are under positive or directional selection. If recombination
is weak, an optimal &lt;em&gt;AB&lt;/em&gt; combination can never appear. &lt;em&gt;A&lt;/em&gt; and &lt;em&gt;B&lt;/em&gt; interfere
with each other.&lt;/p&gt;

&lt;p&gt;Those are the typical Hill-Robertson effects, as described by Hill and Robertson
in 1966. They have been described under other declination since.&lt;/p&gt;

&lt;h2 id=&#34;selective-sweep:b3a64479fb0577dd0f334345c4d6837a&#34;&gt;Selective Sweep&lt;/h2&gt;

&lt;p&gt;Consider &lt;em&gt;A&lt;/em&gt;, a strongly advantageous allele, and &lt;em&gt;b&lt;/em&gt; a weakly deleterious
allele. &lt;em&gt;b&lt;/em&gt; is linked to &lt;em&gt;A&lt;/em&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:b3a64479fb0577dd0f334345c4d6837a:They-are-in-link&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:b3a64479fb0577dd0f334345c4d6837a:They-are-in-link&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. The advantageous effects of &lt;em&gt;A&lt;/em&gt; leads to its
invasion in the population. It can even lead to a point of fixation. It is thus
a selective sweep of &lt;em&gt;A&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;But &lt;em&gt;b&lt;/em&gt; is linked to &lt;em&gt;A&lt;/em&gt;. &lt;em&gt;b&lt;/em&gt; will also invade the population, even if it is
deleterious. This is a case of &amp;ldquo;genetic hitch-hiking&amp;rdquo;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:b3a64479fb0577dd0f334345c4d6837a:As-coined-by-Joh&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:b3a64479fb0577dd0f334345c4d6837a:As-coined-by-Joh&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;h2 id=&#34;background-selection:b3a64479fb0577dd0f334345c4d6837a&#34;&gt;Background selection&lt;/h2&gt;

&lt;p&gt;It is the opposite case of selective sweep interference. Consider now &lt;em&gt;B&lt;/em&gt;, a
strongly deleterious allele, and &lt;em&gt;a&lt;/em&gt; a weakly advantageous allele. &lt;em&gt;a&lt;/em&gt; is linked
to &lt;em&gt;B&lt;/em&gt;. The deleterious effects of &lt;em&gt;B&lt;/em&gt; lead to the extinction of &lt;em&gt;B&lt;/em&gt; carrying
individuals.&lt;/p&gt;

&lt;p&gt;But &lt;em&gt;a&lt;/em&gt; is linked to &lt;em&gt;B&lt;/em&gt;. &lt;em&gt;a&lt;/em&gt; will disappear from the population, even if it is
advantageous. This is a case of background selection. All polymorphism linked to
a strongly deleterious allele is purged.&lt;/p&gt;

&lt;h2 id=&#34;muller-s-ratchet:b3a64479fb0577dd0f334345c4d6837a&#34;&gt;Muller&amp;rsquo;s Ratchet&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Muller&amp;rsquo;s ratchet was first described in 1932.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It happens in clonal species, with small population sizes. A population carrying
no deleterious mutation is a population subgroup. When the first deleterious
mutation appears, the population ratchets up on the mutational burden. Since
recombination is weak, given the small population size, this mutation has no
chance to be cured. When further deleterious mutation occurs, population
degenerate. Its fitness irresistibly drops down, to the point of extinction.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:b3a64479fb0577dd0f334345c4d6837a&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Hill-Robertson effects only occurs when recombination is weaker than mutation.
Polymorphism decreases and selection efficacy decreases too. One must consider
selection intensity, mutation and recombination respective rates. The size of
the genomic window affected depends on those three parameters : if recombination
is weak and selection strong, genome can be affected on a large scale.&lt;/p&gt;

&lt;p&gt;Hill-Robertson effects can explain counter intuitive observations. The spread of
deleterious allele can be explained by genomic interference, as is the case with
cystic fibrosis.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:b3a64479fb0577dd0f334345c4d6837a:They-are-in-link&#34;&gt;They are in &lt;em&gt;linkage desequilibrium&lt;/em&gt; &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:b3a64479fb0577dd0f334345c4d6837a:They-are-in-link&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:b3a64479fb0577dd0f334345c4d6837a:As-coined-by-Joh&#34;&gt;As coined by John Maynard Smith&amp;rdquo; &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:b3a64479fb0577dd0f334345c4d6837a:As-coined-by-Joh&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Starting a blog</title>
      <link>http://sam217pa.github.io/2015/10/14/2015-10-14-starting-a-blog/</link>
      <pubDate>Wed, 14 Oct 2015 16:38:14 +0200</pubDate>
      
      <guid>http://sam217pa.github.io/2015/10/14/2015-10-14-starting-a-blog/</guid>
      <description>

&lt;p&gt;Following the advice of
&lt;a href=&#34;http://www.amazon.com/Pragmatic-Thinking-Learning-Refactor-Programmers/dp/1934356050&#34;&gt;Andy Hunt&lt;/a&gt;,
I decided to start a blog. I want to be able to communicate my ideas in the most
limpid way. Being a non-native English speaker, it is crucial for me to get used
to write in English.&lt;/p&gt;

&lt;h1 id=&#34;goal:73ae8c74cf7ae711ef861e36cba96620&#34;&gt;Goal&lt;/h1&gt;

&lt;p&gt;I am currently learning population genomics, applied to microbial communities.
Me and my supervisors are studying a biased gene conversion process in bacteria,
using a natural transformation model of recombination : &lt;em&gt;Acinetobacter&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;I have never been exposed to such concepts, yet they seem really appealing to
me. I want to be able to put some clear reasoning on concepts I have learned so
far. Writing a blog is perfect for that.&lt;/p&gt;

&lt;h1 id=&#34;an-aspiring-bacterial-evolutionnist:73ae8c74cf7ae711ef861e36cba96620&#34;&gt;An aspiring bacterial evolutionnist&lt;/h1&gt;

&lt;p&gt;Here I&amp;rsquo;ll try to expose stuff that I learned during my late readings and
research paper gamblingâ€¦&lt;/p&gt;

&lt;p&gt;I mostly do microbiology and evolution on a computer, using &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;Python&lt;/code&gt;,
and I try my best to be good at it. I&amp;rsquo;ll certainly blog on it sometimes.&lt;/p&gt;

&lt;p&gt;I also loves &lt;a href=&#34;https://github.com/syl20bnr/spacemacs&#34;&gt;Emacs&lt;/a&gt;, on which I&amp;rsquo;ll try
to blog some other times.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>