<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bacterial Finches</title>
    <link>https://sam217pa.github.io/</link>
    <description>Recent content on Bacterial Finches</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Samuel Barreto</copyright>
    <lastBuildDate>Tue, 13 Sep 2016 19:02:47 +0200</lastBuildDate>
    <atom:link href="https://sam217pa.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>From helm, to ivy</title>
      <link>https://sam217pa.github.io/2016/09/13/from-helm-to-ivy/</link>
      <pubDate>Tue, 13 Sep 2016 19:02:47 +0200</pubDate>
      
      <guid>https://sam217pa.github.io/2016/09/13/from-helm-to-ivy/</guid>
      <description>&lt;p&gt;Recently, I have seen a lot of Emacs users showing interest in Ivy.
Most of them already know Helm or Ido. When someone asked
&lt;a href=&#34;https://www.reddit.com/r/emacs/comments/51lqn9/helm_or_ivy/&#34;&gt;Helm or Ivy?&lt;/a&gt;
on reddit, I thought that I could give my opinion on Ivy, since I am
an ex-Helm zealot.&lt;/p&gt;


&lt;figure &gt;
    &lt;a href=&#34;http://www.feer-mcqueen.com/blog/minimalism-vs-maximalism/&#34;&gt;
        &lt;img src=&#34;http://www.feer-mcqueen.com/blog/wp-content/uploads/2015/11/miimalism-vs.-maximilasim-700x334.jpg&#34; alt=&#34;Maximalists vs minimalists.&#34; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        &lt;p&gt;
        Maximalists vs minimalists.
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;&lt;strong&gt;Helm and Ivy are completion frameworks&lt;/strong&gt;. It means they are tools
that the Emacs ecosystem can use to narrow the field of possibilities
after a given user input. The most common example that comes to mind
is searching for files. Helm and Ivy helps the user to quickly search
for files.&lt;/p&gt;

&lt;p&gt;They are frameworks. It means they can be used by much more complex
commands that needs narrowing or completion. As an example, Helm has a
command that emulate the google search bar, and get google suggests as
you type (&lt;code&gt;helm-google-suggest&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Ivy and Helm have very similar goals, but the approach they take is
very different.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Here I want to compare the tools, from a user point of view.&lt;/strong&gt; What
I mean by user perspective is that I want to compare Ivy and Helm
without knowing how they works internally. I do not know enough
&lt;code&gt;elisp&lt;/code&gt; to be able to compare their internals. But I used them both,
and can give you my feedback on how I, as a &lt;em&gt;user&lt;/em&gt;, felt the
difference between the tools. And finally, why I switched from Helm to
Ivy.&lt;/p&gt;

&lt;p&gt;I want to start with Helm. When I used Spacemacs, I learned the Helm
way. I learned how to &lt;em&gt;use&lt;/em&gt; it, how to &lt;em&gt;customize&lt;/em&gt; it, and how to
&lt;em&gt;tailor&lt;/em&gt; it to my needs. I guess I would qualify as a medium-level
Helm user. I have read
&lt;a href=&#34;http://tuhdo.github.io/helm-intro.html&#34;&gt;this post&lt;/a&gt; and
&lt;a href=&#34;http://tuhdo.github.io/helm-projectile.html&#34;&gt;this one&lt;/a&gt; and
&lt;a href=&#34;https://github.com/emacs-helm/helm/wiki&#34;&gt;this wiki too&lt;/a&gt;, and used it
every day for one year.&lt;/p&gt;


&lt;figure &gt;
    &lt;a href=&#34;https://www.pexels.com/photo/red-closed-penknife-on-the-desk-6172/&#34;&gt;
        &lt;img src=&#34;https://s13.postimg.org/kre67gsfr/swiss_knife.jpg&#34; alt=&#34;Helm is an Emacs swiss knife.&#34; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        &lt;p&gt;
        Helm is an Emacs swiss knife.
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;&lt;strong&gt;Helm is a very mature tool.&lt;/strong&gt; According to its git commit history,
work on Helm really started around 2009. At the time of writing, the
official Helm git repository has 26k lines of emacs-lisp code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/emacs-helm/helm.git
cd helm
cat *.el | wc -l
# =&amp;gt; 26431
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This does not take into account the 142 packages that a query for
&amp;ldquo;helm&amp;rdquo; returns on MELPA. You can do anything with Helm&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;Its main strength is that you can integrate and wrap many Emacs
behavior with it. You can build an interface totally centered around
Helm, just like Spacemacs did. It allows for a really really
consistent interface. Everything goes through Helm.&lt;/p&gt;

&lt;p&gt;You can search files, search buffer, search colors, search project,
search recently edited files, search system process, search music,
search the internet, search completion, search snippets, search
regexp, search commands, documentation, a-propos, infos, … You can
manage your project with Helm-projectile, a nice wrapping around
Projectile. You can generate gitignore with
&lt;a href=&#34;https://www.gitignore.io/&#34;&gt;gitignore.io&lt;/a&gt;. You can manage your
bibliography with Helm-bibtex. You can browse Firefox bookmarks.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://s9.postimg.org/vk1xngpn3/helm_google_suggest.gif&#34; alt=&#34;Search Google from Emacs with Helm.&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;p&gt;
        Search Google from Emacs with Helm.
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;You can do anything with Helm.&lt;/p&gt;

&lt;p&gt;One feature I want to highlight, based on feedbacks from tuhdo
&lt;a href=&#34;https://www.reddit.com/r/emacs/comments/52lnad/from_helm_to_ivy_a_user_perspective/d7lypeu&#34;&gt;here on Reddit&lt;/a&gt;,
is that Helm does not use the minibuffer&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;, while Ivy does. So it
can be configured to open always in the currently opened window. It is
a very neat feature for users with large or ultrawide monitors. Eyes
do not have to travel back and forth to the minibuffer: completion
results are always printed in the same window.&lt;/p&gt;


&lt;figure &gt;
    &lt;a href=&#34;https://www.reddit.com/r/emacs/comments/52lnad/from_helm_to_ivy_a_user_perspective/d7lypeu&#34;&gt;
        &lt;img src=&#34;http://i.imgur.com/g1Oz9JY.png&#34; alt=&#34;Helm configured to open in the currently active window&#34; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        &lt;p&gt;
        Helm configured to open in the currently active window
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;The end result is a very convenient tool to use, as the great majority
of Spacemacs users can tell you. The major drawback it has is that
it is a big behemoth size package. I think it is an &lt;code&gt;elisp&lt;/code&gt; exploit
from the devs to have succeeded in making Helm a very fast tool
despite its size.&lt;/p&gt;

&lt;p&gt;And yet it sometimes feels like an overblown solution to simple
problems. It can be clumsy to configure. It can sometimes have strange
behaviors, causing lags or make Emacs use 100% of a core, even for
simple queries. Maybe an expert Helm user reading this can put those
lags on me not being an &lt;code&gt;elisp&lt;/code&gt; expert, but still. Despite having used
it for more than a year, I did not find the way to make it more
stable. I think it tells something about the &amp;ldquo;overblown problem&amp;rdquo; I was
talking about.&lt;/p&gt;

&lt;p&gt;You can do anything with Helm. But you don&amp;rsquo;t need to. Just because you
can does not mean you should. After a year of using it, I can tell you
that I have only used a third or less of Helm&amp;rsquo;s abilities. Some
functions I thought were great, I re-discovered by reading
&lt;a href=&#34;http://tuhdo.github.io/helm-intro.html&#34;&gt;this post&lt;/a&gt; yesterday. Most of
the time, I used simple commands to switch buffers, or list files.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Helm is only a package for completion, just like ido or ivy. It may
be easy to use, once someone has gone through the trouble of setting
it up, but it&amp;rsquo;s hard to get it to do exactly what you want. Some
people are fine with black boxes, as long as they give them nice
things, I&amp;rsquo;m not.&lt;/p&gt;

&lt;p&gt;— abo-abo, developper of Ivy, on the &amp;ldquo;Why not Helm ?&amp;rdquo; issue,
&lt;a href=&#34;https://github.com/abo-abo/swiper/issues/3&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;


&lt;figure &gt;
    &lt;a href=&#34;https://headseye.wordpress.com/2012/05/19/opinel-no-7/&#34;&gt;
        &lt;img src=&#34;https://s13.postimg.org/vcy1jgyrb/opinel.jpg&#34; alt=&#34;Ivy does only one thing. And …&#34; /&gt;
    &lt;/a&gt;
    
    &lt;figcaption&gt;
        &lt;p&gt;
        Ivy does only one thing. And …
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;&lt;strong&gt;Ivy strives for minimalism, simplicity, customizability and
discoverability.&lt;/strong&gt; Those four adjectives tells a lot about the
paradigm difference between the two. Read
&lt;a href=&#34;http://oremacs.com/swiper/&#34;&gt;the introduction&lt;/a&gt; of the Ivy
documentation to have a good idea of what Ivy strives for.&lt;/p&gt;

&lt;p&gt;At the time of writing, Ivy only has 3.4k lines of code. The ecosystem
built around it — &lt;em&gt;ie&lt;/em&gt; Swiper and Counsel — is 7.5k lines of code
long.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/abo-abo/swiper.git
cd swiper
## Only ivy ?
cat ivy.el | wc -l
# =&amp;gt; 3442

## count lines of code into the whole swiper ecosystem
cat *.el | wc -l
# =&amp;gt; 7526
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ivy is really simple to use. Here is my whole setup.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(use-package ivy :ensure t
  :diminish (ivy-mode . &amp;quot;&amp;quot;)
  :bind
  (:map ivy-mode-map
   (&amp;quot;C-&#39;&amp;quot; . ivy-avy))
  :config
  (ivy-mode 1)
  ;; add ‘recentf-mode’ and bookmarks to ‘ivy-switch-buffer’.
  (setq ivy-use-virtual-buffers t)
  ;; number of result lines to display
  (setq ivy-height 10)
  ;; does not count candidates
  (setq ivy-count-format &amp;quot;&amp;quot;)
  ;; no regexp by default
  (setq ivy-initial-inputs-alist nil)
  ;; configure regexp engine.
  (setq ivy-re-builders-alist
	;; allow input not in order
        &#39;((t   . ivy--regex-ignore-order))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ivy is unobtrusive. It does not want you to integrate everything with
it. It simply is the power house of your completion. You cannot do
everything that the Helm ecosystem does with Ivy. So why did I
switched to Ivy ?&lt;/p&gt;

&lt;p&gt;Despite being minimalistic, I was able to replace most of my common
Helm use cases with Ivy. Because Ivy is so minimalistic, abo-abo built
a package on top of it called Counsel. Counsel offers you many many
tricks that you might like from Helm.&lt;/p&gt;

&lt;p&gt;You can switch buffers, search files, get project-wide search and
replace, get Projectile integration, search recently edited files,
search Emacs command, search documentation, search keybindings, browse
the kill-ring …&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://s18.postimg.org/dunrn0eg9/swiper.gif&#34; alt=&#34;Searching with Swiper. Really really fast.&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;p&gt;
        Searching with Swiper. Really really fast.
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;&lt;strong&gt;Let me describe how I replaced Helm with Ivy.&lt;/strong&gt; Here is an overview
of the most common Helm commands I needed to replace with Ivy. It was
basically the functions I used all the time. I &lt;code&gt;ivy-switch-buffer&lt;/code&gt; like
three times per minute. I used &lt;code&gt;helm-swoop&lt;/code&gt; fifty times a day, and
&lt;code&gt;swiper&lt;/code&gt; is just as good if not better. It is faster. For huge files,
Counsel has &lt;code&gt;counsel-grep-or-swiper&lt;/code&gt;. I have tested it on really
really huge made up files (1M lines or so). It did not tremble.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Helm&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Ivy&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;What ?&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;helm-mini&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;ivy-switch-buffer&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;search for currently opened buffers&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;helm-recentf&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;counsel-recentf&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;search for recently edited files&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;helm-find-files&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;counsel-find-files&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;search files starting from &lt;code&gt;./&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;helm-ag&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;counsel-ag&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;search regexp occurence in current project&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;helm-grep-do-git-grep&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;counsel-git-grep&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;search regexp in current project&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;helm-swoop&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;swiper&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;search string interactively in current buffer&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;helm-show-kill-ring&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;counsel-yank-pop&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;search copy-paste history&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;helm-projectile&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;counsel-projectile&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;search project and file in it&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;helm-ls-git-ls&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;counsel-git&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;search file in current git project&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;helm-themes&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;counsel-load-theme&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;switch themes&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;helm-descbinds&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;counsel-descbinds&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;describe keybindings and associated functions&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;helm-M-x&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;counsel-M-x&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;enhanced M-x command&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;I think you can see that Ivy based commands have nothing to be ashamed
of. They can replace every common use cases of Helm. I am not saying
that you can do everything Helm does with Ivy. But it is already very
convenient. And as I said, I don&amp;rsquo;t need to do everything Helm does.&lt;/p&gt;

&lt;p&gt;To speak of completion paradigm, the difference is not that obvious
between Helm and Ivy. What I can tell you, as a &lt;em&gt;user&lt;/em&gt;, is that Ivy
&lt;em&gt;feels&lt;/em&gt; less cluttered, snappier, more intuitive, self-explanatory and
really understandable. Every completion is predictable.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;In the end, it really is a matter of personal taste.&lt;/strong&gt; To me the
&amp;ldquo;Ivy or Helm&amp;rdquo; debate is very similar to debates likes Emacs or
Spacemacs, Emacs or an IDE, C or Java, minimalistic or full-blown.
Thelonious or Duke. Van Der Rohe or Gaudi.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://s13.postimg.org/5321kot1z/van_der_rohe.png&#34; alt=&#34;This Mies Van Der Rohe designed pavillion is to architecture what Ivy is to Emacs.&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;p&gt;
        This Mies Van Der Rohe designed pavillion is to architecture what Ivy is to Emacs.
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;



&lt;figure &gt;
    
        &lt;img src=&#34;https://s13.postimg.org/ad70bzdav/gaudi.jpg&#34; alt=&#34;The Gaudi way. The Helm way.&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;p&gt;
        The Gaudi way. The Helm way.
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;With Helm you get a huge package, a full list of features you will
never use, a whole bunch of functions you will use occasionally, and a
short list of functions you will use fifty times an hour. With Ivy you
get a small package with only essentials functions that does not get
in your way, and that you can extend easily through Counsel or very
simple functions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(ivy-read &amp;quot;Pick:&amp;quot; (mapcar #&#39;number-to-string (number-sequence 1 10)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With Helm:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(helm
 :sources
  (helm-build-sync-source &amp;quot;one-to-ten&amp;quot;
    :candidates
    (mapcar #&#39;number-to-string (number-sequence 1 10))
    :fuzzy-match t)
  :buffer
  &amp;quot;*helm one-to-ten*&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or the simpler form:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(helm-comp-read &amp;quot;Pick:&amp;quot; (mapcar #&#39;number-to-string (number-sequence 1 10)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Helm makes a lot of choices for the users. Ivy lets them tailor it to
their needs. Helm uses a lot of memory to be very fast. Ivy stays
simple to be very fast. Helm is mature. Ivy is young. Helm offers
consistency across Emacs. Ivy offers simplicity and predictability.
Helm ask you a rather involved setup. Ivy works out of the box.&lt;/p&gt;

&lt;p&gt;I am a little biased towards Ivy, since I use it. It suits my tastes
better. But as a user, Helm and Ivy does not feel that different. They
are both great packages, that chose a very different approach for the
same goal.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;reddit-embed&#34; data-embed-media=&#34;www.redditmedia.com&#34;
data-embed-parent=&#34;false&#34; data-embed-live=&#34;false&#34;
data-embed-uuid=&#34;36b96121-6628-470a-82a9-dbacdc593a42&#34;
data-embed-created=&#34;2016-09-13T11:22:25.426Z&#34;&gt;&lt;a
href=&#34;https://www.reddit.com/r/emacs/comments/51lqn9/helm_or_ivy/d7dmed8&#34;&gt;Comment&lt;/a&gt;
from discussion &lt;a
href=&#34;https://www.reddit.com/r/emacs/comments/51lqn9/helm_or_ivy/&#34;&gt;Helm
or ivy?&lt;/a&gt;.&lt;/div&gt;&lt;script async
src=&#34;https://www.redditstatic.com/comment-embed.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;The package that inspired Helm is called Anything by the way.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;The line at the bottom of your screen that you use when you type M-x for example.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Nuclear weapon multi-editing via Ivy and Ag</title>
      <link>https://sam217pa.github.io/2016/09/11/nuclear-power-editing-via-ivy-and-ag/</link>
      <pubDate>Sun, 11 Sep 2016 12:36:10 +0200</pubDate>
      
      <guid>https://sam217pa.github.io/2016/09/11/nuclear-power-editing-via-ivy-and-ag/</guid>
      <description>

&lt;p&gt;Sometimes when I am working on a project, I use project-wide variable or
function definition. So I name them.&lt;/p&gt;

&lt;p&gt;I usually suck at naming.&lt;/p&gt;

&lt;p&gt;So when I think of a better name, I need a way to change it globally, &lt;em&gt;ie&lt;/em&gt; in
all the files of the current project that uses it.&lt;/p&gt;

&lt;p&gt;In Spacemacs, I have heard of what Fabien Dubosson, one of the main Spacemacs
dev, called the
&lt;a href=&#34;https://gitter.im/syl20bnr/spacemacs?at=573d831c0cb634927f80545e&#34;&gt;&amp;ldquo;nuclear weapon of multi-editing&amp;rdquo;&lt;/a&gt;.
When I switched from Helm to Ivy, I looked for a way to do the same thing.&lt;/p&gt;

&lt;p&gt;It turned out that Ivy-occur has nice integration with Wgrep since Ivy version
&lt;a href=&#34;http://oremacs.com/2016/04/26/ivy-0.8.0/&#34;&gt;0.8&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;nuclear-weapon-multi-editing&#34;&gt;Nuclear-weapon multi-editing :&lt;/h1&gt;

&lt;p&gt;I call &lt;code&gt;counsel-ag&lt;/code&gt;, to search for the string I want to modify in the current
directory. By default, &lt;code&gt;ag&lt;/code&gt; (and &lt;code&gt;counsel-ag&lt;/code&gt;) will ignore files ignored by git.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://s12.postimg.org/u0co6huct/first_step.png&#34; alt=&#34;Call counsel-ag and type edit&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;p&gt;
        Call counsel-ag and type edit
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;I press &lt;code&gt;C-c C-o&lt;/code&gt; (&lt;code&gt;ivy-occur&lt;/code&gt;) in the search result. It opens an &lt;code&gt;ivy-occur&lt;/code&gt;
buffer.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://s10.postimg.org/ssiucf35l/second_step.png&#34; alt=&#34;Press C-c C-o prints this buffer.&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;p&gt;
        Press C-c C-o prints this buffer.
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;I switch to this buffer and press &lt;code&gt;C-x C-q&lt;/code&gt; (&lt;code&gt;ivy-wgrep-change-to-wgrep-mode&lt;/code&gt;)
to edit it. I can now change each variable name globally using normal search and
replace techniques. I use Evil-ex commands &lt;code&gt;:%s/pattern/replace/g&lt;/code&gt; but you may
use others as well (I have heard good things of Iedit too…).&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://s14.postimg.org/s6ahj1eq9/third_step.png&#34; alt=&#34;Replace edit globally with potatoes.&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;p&gt;
        Replace edit globally with potatoes.
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;I then press &lt;code&gt;C-c C-c&lt;/code&gt; (&lt;code&gt;wgrep-finish-edit&lt;/code&gt;). Now every occurence of the word
&lt;em&gt;edit&lt;/em&gt; in all files has been replaced with &lt;em&gt;potatoes&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ivy is great.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Multilingual Hugo blog with GitHub Pages and Emacs</title>
      <link>https://sam217pa.github.io/2016/09/09/setup-a-multilingual-hugo-blog-with-emacs-and-github/</link>
      <pubDate>Fri, 09 Sep 2016 14:29:08 +0200</pubDate>
      
      <guid>https://sam217pa.github.io/2016/09/09/setup-a-multilingual-hugo-blog-with-emacs-and-github/</guid>
      <description>

&lt;p&gt;Hugo is a great platform to deploy a blog with. Unfortunately and unlike Jekyll,
I found it not very handy to setup a multilingual blog with. It has support for
&lt;a href=&#34;https://gohugo.io/tutorials/create-a-multilingual-site/&#34;&gt;multilingual blog&lt;/a&gt;,
but I think it is kind of hard to follow the guide.&lt;/p&gt;

&lt;p&gt;So I decided to simply use git and git branches to build my blog with. And it
works really well. If you are interested in building a multilingual blog with
Hugo and GitHub Pages, please follow along.&lt;/p&gt;

&lt;p&gt;We are going to use the &lt;code&gt;master&lt;/code&gt; branch to manage the english content of a hugo
website, and a &lt;code&gt;french&lt;/code&gt; branch to translate this content to another hugo
website. The static english version of the site will be served by your GitHub
Pages main page, and the static french version will be served by the &lt;code&gt;gh-pages&lt;/code&gt;
branch of another repo.&lt;/p&gt;

&lt;h1 id=&#34;first-things-first-create-your-blog&#34;&gt;First things first, create your blog&lt;/h1&gt;

&lt;p&gt;Hugo has a really nice &lt;a href=&#34;https://gohugo.io/overview/quickstart/&#34;&gt;tutorial&lt;/a&gt; to
explain how to create your website with it, but I want to explain some steps in
a little more details. Type the following command at the command line to create
a scaffold of a hugo website in the &lt;code&gt;my-website&lt;/code&gt; directory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;hugo new site my-website
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now type this one to go into your hugo website and download a theme to use for
your blog. I chosed &lt;code&gt;ghostwriter&lt;/code&gt; for obvious reasons but there are lots of
other good themes for hugo.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd my-website
mkdir themes
cd themes
git clone https://github.com/jbub/ghostwriter
cd ..
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now edit &lt;code&gt;config.toml&lt;/code&gt; and add the following lines to it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;themes = &amp;quot;ghostwriter&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go check &lt;a href=&#34;http://themes.gohugo.io/ghostwriter/&#34;&gt;this page&lt;/a&gt; for explanation on
how to setup a ghostwriter-enabled website.&lt;/p&gt;

&lt;p&gt;Now type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;hugo serve
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It deploys a website on the &lt;a href=&#34;http://localhost:1313/&#34;&gt;http://localhost:1313/&lt;/a&gt; port.&lt;/p&gt;

&lt;h1 id=&#34;write-your-first-post&#34;&gt;Write your first post&lt;/h1&gt;

&lt;p&gt;Type :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;hugo new post/my-first-post-ever.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to create a new post and edit it with your favorite editor. Of course, at this
point your favorite editor should be Emacs, for reasons I&amp;rsquo;ll explain below, but
you may chose another.&lt;/p&gt;

&lt;p&gt;Now that you are satisfied with your first post, we are going to use git to
manage the building of our website.&lt;/p&gt;

&lt;h1 id=&#34;manage-your-blog-with-git&#34;&gt;Manage your blog with git&lt;/h1&gt;

&lt;p&gt;Type the following commands at the command line.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git init
echo &amp;quot;public/&amp;quot; &amp;gt; .gitignore
echo &amp;quot;public-fr/&amp;quot; &amp;gt;&amp;gt; .gitignore
echo &amp;quot;themes/&amp;quot; &amp;gt;&amp;gt; .gitignore
git add .
git commit -m &amp;quot;first commit and first post&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Git must not track the &lt;code&gt;themes&lt;/code&gt; and &lt;code&gt;public&lt;/code&gt; directories. The themes directory
is already managed by git, since the themes are on their own git repo. The
public directories are going to be the directory that contains the static
version of our website, and will point to another repo.&lt;/p&gt;

&lt;p&gt;Now the master branch is setup to track the &amp;ldquo;english&amp;rdquo; version of your blog. We
must setup a branch to track the &amp;ldquo;french&amp;rdquo; (or german or swahili if you prefer
swahili to french) version of our blog.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git branch french
git checkout french
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now edit your first post, and translate everything that need to be translated in
french (or swahili).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git add content/post/my-first-post-ever.md
git commit -m &amp;quot;translated first post in english&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We now need to build the website with hugo. We are going to deploy the french
version in &lt;code&gt;public-fr&lt;/code&gt; and the english version in &lt;code&gt;public&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir public-fr
hugo -d public-fr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you &lt;code&gt;ls public-fr&lt;/code&gt;, you will see that hugo built the static website. Let us
deploy the english version.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git checkout master
hugo -d public
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;host-your-pages-on-github-pages&#34;&gt;Host your pages on GitHub Pages&lt;/h1&gt;

&lt;p&gt;Now follow the instruction &lt;a href=&#34;https://pages.github.com/&#34;&gt;here&lt;/a&gt; to use GitHub pages
to deploy your own website.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd public
git init
echo &amp;quot;# english version of my personal website&amp;quot; &amp;gt; README.md
git add .
git commit -m &amp;quot;website updated&amp;quot;
git remote add origin https://github.com/username/username.git
git push -u
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are going to use another GitHub repo to publish the french version of the
website. Open a new repo on github, and call it &lt;code&gt;fr&lt;/code&gt;, or &lt;code&gt;sw&lt;/code&gt; if you still
prefer swahili. Now type at the command line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd ../public-fr/
git init
echo &amp;quot;# french version of my personal website&amp;quot; &amp;gt; README.md
git add .
git commit -m &amp;quot;site à jour&amp;quot;
git branch gh-pages
git checkout gh-pages
git remote add origin https://github.com/username/fr.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;GitHub will now serve the french version of your website to
&lt;a href=&#34;https://yourusername.github.io/fr/&#34;&gt;https://yourusername.github.io/fr/&lt;/a&gt;. I really love GitHub Pages.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s it, you can now setup a button as a link that points to your english
version on the french website if you want.&lt;/p&gt;

&lt;h1 id=&#34;use-emacs-to-manage-your-hugo-blog&#34;&gt;Use Emacs to manage your Hugo blog&lt;/h1&gt;

&lt;p&gt;Here I&amp;rsquo;ll just point to another blog post from
&lt;a href=&#34;https://blog.tohojo.dk/2015/10/integrating-hugo-into-emacs.html&#34;&gt;Toke Høiland-Jørgensen&lt;/a&gt;.
He uses some custom elisp to wrap simple Hugo commands and manage his blog from
Emacs.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to build your own spacemacs</title>
      <link>https://sam217pa.github.io/2016/09/02/how-to-build-your-own-spacemacs/</link>
      <pubDate>Fri, 02 Sep 2016 21:29:21 +0200</pubDate>
      
      <guid>https://sam217pa.github.io/2016/09/02/how-to-build-your-own-spacemacs/</guid>
      <description>

&lt;p&gt;Emacs is a great environment to build a text editor. Being a really old piece of
software, searching the internet does not always lead to the best or more recent
results. My goal is to help you build an editor inside Emacs using the best
tools for the job, with modern tools and well-crafted packages.&lt;/p&gt;

&lt;p&gt;In &lt;a href=&#34;http://sam217pa.github.io/2016/08/30/how-to-make-your-own-spacemacs/&#34;&gt;a previous post&lt;/a&gt;,
I described the tools I needed to build myself a great spacemacs-like&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; experience
inside emacs. In this post, I want to explain the process of building it in more
details. I hope it serves you in building a cool editor the way you like it.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://blog.oxforddictionaries.com/wp-content/uploads/pottery-wheel.jpg&#34; alt=&#34;Let&amp;#39;s make Emacs the way you like it&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;p&gt;
        Let&amp;#39;s make Emacs the way you like it
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;blockquote&gt;
&lt;p&gt;Emacs proficient reader should skip this part and jump directly to the
&lt;code&gt;use-package&lt;/code&gt; part &lt;a href=&#34;#use-package&#34;&gt;here&lt;/a&gt;. Those that already know
about &lt;code&gt;use-package&lt;/code&gt; should jump &lt;a href=&#34;#move-in-emacs&#34;&gt;here&lt;/a&gt;, where I
talk about &lt;code&gt;ivy&lt;/code&gt;, &lt;code&gt;swiper&lt;/code&gt;, &lt;code&gt;counsel&lt;/code&gt; and &lt;code&gt;general&lt;/code&gt;. Those that do not want to
read all my strange french-english prose can and should jump directly to
&lt;a href=&#34;#recipe&#34;&gt;here&lt;/a&gt;. I have put up a recipe to a modern Emacs
experience.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Emacs is a text editor and a programming environment built on top of a
programming language, just like Python or Java, called &lt;em&gt;emacs-lisp&lt;/em&gt;. The text
editing abilities of a bare Emacs distribution are decent, but today most Emacs
users extend it through other pieces of software called modules or packages.
They are also written in emacs-lisp, often by user of Emacs that became
frustrated by a lack of feature or thought they could do better. The result is a
big ecosystem of emacs-lisp packages, of which you can get an idea at
&lt;a href=&#34;https://melpa.org&#34;&gt;melpa.org&lt;/a&gt;. Anybody can download it and use it to extend the
functionnalities of emacs.&lt;/p&gt;

&lt;p&gt;One of the main strength of Emacs is its extensibility and flexibility. As our
first step, we are going to learn how to configure it using basic emacs
function.&lt;/p&gt;

&lt;h2 id=&#34;getting-emacs-ready-for-the-job&#34;&gt;Getting Emacs ready for the job&lt;/h2&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://images.unsplash.com/photo-1461896836934-ffe607ba8211&#34; alt=&#34;Get ready.&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;p&gt;
        Get ready.
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Once you have installed the most recent version of Emacs using your beloved
package manage and opened it, Emacs will create a directory in your &lt;code&gt;$HOME&lt;/code&gt;
directory called &lt;code&gt;~/.emacs.d&lt;/code&gt;. When Emacs start, it reads a file in this
directory called &lt;code&gt;~/.emacs.d/init.el&lt;/code&gt;, and execute any emacs-lisp command it
finds in it. We are going to use this file to customize emacs to our liking.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;As a version control adept, I have symlinked &lt;code&gt;init.el&lt;/code&gt; to a dotfile repository
under VC.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;When inside Emacs, press &lt;code&gt;C-x C-f&lt;/code&gt; (meaning &lt;code&gt;control-f&lt;/code&gt; then &lt;code&gt;control-f&lt;/code&gt;), the
emacs command to open a file. Emacs will prompt you for a file to open, and
type &lt;code&gt;~/.emacs.d/init.el&lt;/code&gt;. Emacs being really old, some of its default
configuration are somewhat — er — mysterious and mystical. We are going to use
&lt;code&gt;init.el&lt;/code&gt; to introduce some sane defaults. Paste the following chunks using
&lt;code&gt;C-y&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(setq delete-old-versions -1 )		; delete excess backup versions silently
(setq version-control t )		; use version control
(setq vc-make-backup-files t )		; make backups file even when in version controlled dir
(setq backup-directory-alist `((&amp;quot;.&amp;quot; . &amp;quot;~/.emacs.d/backups&amp;quot;)) ) ; which directory to put backups file
(setq vc-follow-symlinks t )				       ; don&#39;t ask for confirmation when opening symlinked file
(setq auto-save-file-name-transforms &#39;((&amp;quot;.*&amp;quot; &amp;quot;~/.emacs.d/auto-save-list/&amp;quot; t)) ) ;transform backups file name
(setq inhibit-startup-screen t )	; inhibit useless and old-school startup screen
(setq ring-bell-function &#39;ignore )	; silent bell when you make a mistake
(setq coding-system-for-read &#39;utf-8 )	; use utf-8 by default
(setq coding-system-for-write &#39;utf-8 )
(setq sentence-end-double-space nil)	; sentence SHOULD end with only a point.
(setq default-fill-column 80)		; toggle wrapping text at the 80th character
(setq initial-scratch-message &amp;quot;Welcome in Emacs&amp;quot;) ; print a default message in the empty scratch buffer opened at startup
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Place your cursor after the closing paren of the first line and press &lt;code&gt;C-x C-e&lt;/code&gt;.
It will execute the previous bits of code. &lt;code&gt;setq&lt;/code&gt; is an emacs-lisp word meaning
&amp;ldquo;set the following variable to the following value&amp;rdquo;. For the first line, we
could translate in plain english to &amp;ldquo;set the variable &lt;em&gt;delete-old-versions&lt;/em&gt; to
-1&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Now save the &lt;code&gt;init.el&lt;/code&gt; modifications by pressing &lt;code&gt;C-x C-s&lt;/code&gt;, and quit Emacs by
pressing &lt;code&gt;C-x C-c&lt;/code&gt;. Restart it. Now press &lt;code&gt;M-x&lt;/code&gt; (depending on your OS, it should
corresponds to &lt;code&gt;Alt-x&lt;/code&gt;) and &lt;code&gt;describe-variable&lt;/code&gt;, then &lt;code&gt;delete-old-versions&lt;/code&gt;. It
should open a buffer with the documentation of the variable, with a line saying
&amp;ldquo;Its value is -1&amp;rdquo;. So basically when Emacs started up, it evaluated the lines of
code in &lt;code&gt;~/.emacs.d/init.el&lt;/code&gt;. Now press &lt;code&gt;M-x&lt;/code&gt; &lt;code&gt;describe-key&lt;/code&gt; and press
&lt;code&gt;C-e&lt;/code&gt;. It should print a buffer describing the function attached to the
keybindings &lt;code&gt;C-e&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;In those simple exercises, we covered very important Emacs notion :&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Every command is bound to a function. Those function are, most of the time,
defined in emacs-lisp. Some very important function are defined in C for
performance.&lt;/li&gt;
&lt;li&gt;You learned that Emacs has a very thorough documentation describing variables,
functions, keybindings…&lt;/li&gt;
&lt;li&gt;You learned to modify a variable using emacs-lisp.&lt;/li&gt;
&lt;li&gt;You learned how Emacs execute code at startup, and we can leverage that to
customize it to our liking.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;use-package&#34;&gt;Introduce structure in your config : &lt;code&gt;use-package&lt;/code&gt; to the rescue&lt;/h2&gt;

&lt;p&gt;The emacs-lisp package archive with wich you can interact at
&lt;a href=&#34;https://melpa.org&#34;&gt;melpa.org&lt;/a&gt; has, at the time of writing 3 291 packages. The
abundance of modules sometimes lead to something that emacs users call &lt;em&gt;Emacs
bankruptcy&lt;/em&gt;: a state in which the user does not understand its own Emacs
configuration.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I give up. During the past 6 years of my emacs career, my emacs configuration
file grew to embarrassing levels. As of this morning, it is well over 1000
lines and is a looming burden of disorganization. Startup time is poor,
customizations exist for languages that I don’t use anymore (ahem,
                                   &amp;gt; csharp-mode), and it has been this way for too long…
—— RyanMcGeary, 2007&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To prevent this, John Wiegley, the current emacs maintainer put up a great
package called &lt;code&gt;use-package&lt;/code&gt;. So, as our second step, we are going to set up
&lt;code&gt;use-package&lt;/code&gt; and use it for the first time. This &amp;ldquo;meta&amp;rdquo;-package is a package to
manage other packages and the way they interact. Put the following lines in your
&lt;code&gt;~/.emacs.d/init.el&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(require &#39;package)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This line basically says to Emacs make available any command present in the
&lt;em&gt;package&lt;/em&gt; module.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(setq package-enable-at-startup nil) ; tells emacs not to load any packages before starting up
;; the following lines tell emacs where on the internet to look up
;; for new packages.
(setq package-archives &#39;((&amp;quot;org&amp;quot;       . &amp;quot;http://orgmode.org/elpa/&amp;quot;)
                         (&amp;quot;gnu&amp;quot;       . &amp;quot;http://elpa.gnu.org/packages/&amp;quot;)
                         (&amp;quot;melpa&amp;quot;     . &amp;quot;https://melpa.org/packages/&amp;quot;)
                         (&amp;quot;marmalade&amp;quot; . &amp;quot;http://marmalade-repo.org/packages/&amp;quot;)))
(package-initialize) ; guess what this one does ?

;; Bootstrap `use-package&#39;
(unless (package-installed-p &#39;use-package) ; unless it is already installed
  (package-refresh-contents) ; updage packages archive
  (package-install &#39;use-package)) ; and install the most recent version of use-package

(require &#39;use-package) ; guess what this one does too ?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the best way to learn how it works is by reading its documentation. Nah.
Let&amp;rsquo;s use it first, read then. Restart emacs and put the following line in your
&lt;code&gt;init.el&lt;/code&gt;, then go to the end of line (&lt;code&gt;C-e&lt;/code&gt;) and press &lt;code&gt;C-x C-e&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(use-package general :ensure t)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It should check for the &lt;code&gt;general&lt;/code&gt; package and make sure it is accessible. If
not, the &lt;code&gt;:ensure t&lt;/code&gt; part of the previous chunks tells use-package to download
it and place it somewhere accessible, in &lt;code&gt;~/.emacs.d/elpa/&lt;/code&gt; by default&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;Now every function in the general package is available to you. We will now use
the same &lt;code&gt;use-package&lt;/code&gt; statement to customize the general package. We need the
&lt;code&gt;:config&lt;/code&gt; keyword of the &lt;code&gt;use-package&lt;/code&gt; macro to do just that.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(use-package general :ensure t
  :config
  (general-define-key &amp;quot;C-&#39;&amp;quot; &#39;avy-goto-word-1)
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The third line said &amp;ldquo;bind to the &lt;code&gt;C-&#39;&lt;/code&gt; press the function &lt;code&gt;avy-goto-word-1&lt;/code&gt;&amp;rdquo;. It
means we need the &lt;code&gt;avy&lt;/code&gt; package. So let&amp;rsquo;s use &lt;code&gt;use-package&lt;/code&gt; again to download
and load the &lt;code&gt;avy&lt;/code&gt; package.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(use-package avy :ensure t)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But then we do not need this package right when we start Emacs. It can wait
until we first call &lt;code&gt;avy-goto-word-1&lt;/code&gt; or any other command from the &lt;code&gt;avy&lt;/code&gt;
package. So we are going to put this command in the list of command that
triggers the loading of the &lt;code&gt;avy&lt;/code&gt; package. We use the &lt;code&gt;:commands&lt;/code&gt; keyword to do
that.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(use-package avy :ensure t
  :commands (avy-goto-word-1))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So now when we start Emacs, the &lt;code&gt;avy&lt;/code&gt; package is not loaded. But when we first
press &lt;code&gt;C-&#39;&lt;/code&gt;, it will call &lt;code&gt;avy-goto-word-1&lt;/code&gt; and trigger the loading of the &lt;code&gt;avy&lt;/code&gt;
package.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://images.unsplash.com/photo-1453230806017-56d81464b6c5?dpr=1&amp;amp;amp&#34; alt=&#34;Your emacs setup after use-package&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;p&gt;
        Your emacs setup after use-package
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Use-package has all kinds of tricks to make sure no code is executed or loaded
before it is needed. You &lt;strong&gt;really&lt;/strong&gt; need to check out &lt;code&gt;use-package&lt;/code&gt; on your way
to mold Emacs to your liking.&lt;/p&gt;

&lt;h2 id=&#34;move-in-emacs&#34;&gt;Move in Emacs : the &lt;em&gt;abo-abo&lt;/em&gt; way&lt;/h2&gt;

&lt;p&gt;In Emacs as in all text editor, you move more than you type. You move between
buffers, &lt;em&gt;ie&lt;/em&gt; text files loaded into memory. You move between lines. You move
between sentences. You move between semantics unit. You move between files. You
search for files. You search for text. You search for regexp. You search for
projects.&lt;/p&gt;

&lt;p&gt;It really helps to have a uniform interface to the most common commands you
call.&lt;/p&gt;

&lt;p&gt;One of the most prolific Emacs-package developper that I know of is called Oleh
Krehel; &lt;a href=&#34;https://twitter.com/_abo_abo&#34;&gt;abo-abo&lt;/a&gt; on Twitter&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;. During the past
two years, he developped an ecosystem around a completion framework that he
wrote called &lt;code&gt;ivy&lt;/code&gt;. This ecosystem is composed of three packages called &lt;code&gt;ivy&lt;/code&gt;,
&lt;code&gt;counsel&lt;/code&gt; and &lt;code&gt;swiper&lt;/code&gt;.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://static.pexels.com/photos/26662/pexels-photo-26662-large.jpg&#34; alt=&#34;Searching with Counsel&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;p&gt;
        Searching with Counsel
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Counsel allow you to find recently visited files, to switch between buffers, to
search for a string in the current git directory, to search for a file in the
current git directory, to search for Emacs function, to search for system
applications to open, to search for music in rythmbox, to … . Well, you get the
idea. Swiper allow you to find text really really quickly inside an Emacs
buffer.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://images.unsplash.com/photo-1466436578965-5cba086a1824&#34; alt=&#34;Ivy is the foundation of the two other.&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;p&gt;
        Ivy is the foundation of the two other.
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Ivy proposes completion candidates to the two other, and to many other Emacs
function that needs completion and narrowing. You may have heard of another
ecosystem centered around Helm. The spacemacs dev chose to use Helm as a central
tool, but I can assure you that you will not regret chosing the Ivy way. It is
really really fast, really well thought out and really convenient to use.&lt;/p&gt;

&lt;p&gt;So now we have a ton on function to bind, and still no way to make that easy.
But do we ?&lt;/p&gt;

&lt;h2 id=&#34;bind-in-emacs&#34;&gt;Bind in Emacs : the &lt;code&gt;general&lt;/code&gt; way&lt;/h2&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://images.unsplash.com/photo-1463527882365-18201e85a091&#34; alt=&#34;Binding via general.&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;p&gt;
        Binding via general.
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Recently, a growing user base of Emacs user started to use Evil, a vim emulation
built on top of Emacs command. It works just flawlessly. When they did, they
developped some ways to bind keys to functions like in Vim. One of the most
successful solution to this is &lt;code&gt;evil-leader&lt;/code&gt;. And then another Evil user by the
pseudo of &lt;code&gt;noctuid&lt;/code&gt; created a package called &lt;code&gt;general.el&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:4&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:4&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;. Of all the way I
know to define keys in Emacs, this one is the most versatile and the simplest
solution to defining keybindings.&lt;/p&gt;

&lt;p&gt;There is many ways to define keybindings in &lt;code&gt;general.el&lt;/code&gt;. Since they are all
constructed around &lt;code&gt;general-define-key&lt;/code&gt;, it is the most flexible. So let&amp;rsquo;s use
that to bind some keys.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(general-define-key
  ;; replace default keybindings
  &amp;quot;C-s&amp;quot; &#39;swiper             ; search for string in current buffer
  &amp;quot;M-x&amp;quot; &#39;counsel-M-x        ; replace default M-x with ivy backend
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This one is pretty simple. It binds &lt;code&gt;C-s&lt;/code&gt; to swiper and &lt;code&gt;M-x&lt;/code&gt; to counsel-M-x.
Those two keys are probably amongs the two most used keybindings in Emacs. But
General allows more complex solution to keybindings definition. Let&amp;rsquo;s say we
want all of our personnal keybindings bound to &lt;code&gt;C-c XY&lt;/code&gt;, where &lt;code&gt;XY&lt;/code&gt; is a
combination of our choice. We can define a &lt;code&gt;:prefix&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(general-define-key
 :prefix &amp;quot;C-c&amp;quot;
 ;; bind to simple key press
  &amp;quot;b&amp;quot;	&#39;ivy-switch-buffer  ; change buffer, chose using ivy
  &amp;quot;/&amp;quot;   &#39;counsel-git-grep   ; find string in git project
  ;; bind to double key press
  &amp;quot;ff&amp;quot;  &#39;counsel-find-file  ; find file using ivy
  &amp;quot;fr&amp;quot;	&#39;counsel-recentf    ; find recently edited files
  &amp;quot;pf&amp;quot;  &#39;counsel-git        ; find file in git project
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now &lt;code&gt;C-c b&lt;/code&gt; switches buffer using Ivy. And &lt;code&gt;C-c f&lt;/code&gt; then &lt;code&gt;f&lt;/code&gt; finds files. And
&lt;code&gt;C-c f&lt;/code&gt; then &lt;code&gt;r&lt;/code&gt; find recent files. Now we can see a pattern here: we just
placed all command related to finding files under a &lt;code&gt;C-c f&lt;/code&gt; prefix. It would be
great if we could know when we press &lt;code&gt;C-c&lt;/code&gt; what the &lt;code&gt;f&lt;/code&gt; corresponds to.&lt;/p&gt;

&lt;p&gt;But hey it is Emacs. There is a package for it. It is called &lt;code&gt;which-key&lt;/code&gt;. So
guess what ?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(use-package which-key :ensure t)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So now when we press &lt;code&gt;C-c&lt;/code&gt;, a nice buffer shows up that pressing &lt;code&gt;b&lt;/code&gt; will
execute &lt;code&gt;ivy-switch-buffer&lt;/code&gt;. But what does it show for &lt;code&gt;f&lt;/code&gt; ? &amp;ldquo;&lt;code&gt;+prefix&lt;/code&gt;&amp;rdquo;. We can
do better. We can indicate to Which-key that &lt;code&gt;C-c f&lt;/code&gt; related functions
corresponds to &lt;em&gt;file&lt;/em&gt; related operations.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(use-package which-key :ensure t
 :config
 (which-key-add-key-based-replacement
  &amp;quot;C-c f&amp;quot; &amp;quot;file&amp;quot;
  &amp;quot;C-c ff&amp;quot; &amp;quot;find file&amp;quot;
  &amp;quot;C-c fr&amp;quot; &amp;quot;recently edited&amp;quot;
  &amp;quot;C-c p&amp;quot;  &amp;quot;project&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Execute this code with &lt;code&gt;C-x C-e&lt;/code&gt; as usual. Now press &lt;code&gt;C-c&lt;/code&gt;, and see how much
&lt;code&gt;which-key&lt;/code&gt; is awesome. Never forget a keybinding. Very easy on beginners. Very
swift. Very clean. Does it ?&lt;/p&gt;

&lt;p&gt;There is some kind of code duplication here. We define it using General, and
describe it using Which-key. In fact we can do both in the same statement, using
Which-key integration to General.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(general-define-key
 :prefix &amp;quot;C-c&amp;quot;
 ;; bind to simple key press
  &amp;quot;b&amp;quot;	&#39;ivy-switch-buffer  ; change buffer, chose using ivy
  &amp;quot;/&amp;quot;   &#39;counsel-git-grep   ; find string in git project
  ;; bind to double key press
  &amp;quot;f&amp;quot;   &#39;(:ignore t :which-key &amp;quot;files&amp;quot;)
  &amp;quot;ff&amp;quot;  &#39;counsel-find-file
  &amp;quot;fr&amp;quot;	&#39;counsel-recentf
  &amp;quot;p&amp;quot;   &#39;(:ignore t :which-key &amp;quot;project&amp;quot;)
  &amp;quot;pf&amp;quot;  &#39;(counsel-git :which-key &amp;quot;find file in git dir&amp;quot;)
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Evaluate this code. Press &lt;code&gt;C-c&lt;/code&gt;. Same output as before. See how General is great
?&lt;/p&gt;

&lt;h2 id=&#34;meeting-our-goal-build-yourself-a-great-spacemacs-like-experience&#34;&gt;Meeting our goal: build yourself a great Spacemacs-like experience&lt;/h2&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://images.unsplash.com/photo-1443928281170-6900dc50ac55&#34; alt=&#34;On the road to a great emacs experience&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;p&gt;
        On the road to a great emacs experience
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;For Evil users out there, General also has nice integration with Evil states. It
means that we can easily define keybindings to match Spacemacs design styles.
And yet we retain the ability to build the editor we want. That is what we came
to Emacs in the beginning.&lt;/p&gt;

&lt;p&gt;Check out what this chunk does.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(use-package general :ensure t
  :config
  (general-define-key
   :states &#39;(normal visual insert emacs)
   :prefix &amp;quot;SPC&amp;quot;
   :non-normal-prefix &amp;quot;C-SPC&amp;quot;

    ;; simple command
    &amp;quot;&#39;&amp;quot;   &#39;(iterm-focus :which-key &amp;quot;iterm&amp;quot;)
    &amp;quot;?&amp;quot;   &#39;(iterm-goto-filedir-or-home :which-key &amp;quot;iterm - goto dir&amp;quot;)
    &amp;quot;/&amp;quot;   &#39;counsel-ag
    &amp;quot;TAB&amp;quot; &#39;(switch-to-other-buffer :which-key &amp;quot;prev buffer&amp;quot;)
    &amp;quot;SPC&amp;quot; &#39;(avy-goto-word-or-subword-1  :which-key &amp;quot;go to char&amp;quot;)

    ;; Applications
    &amp;quot;a&amp;quot; &#39;(:ignore t :which-key &amp;quot;Applications&amp;quot;)
    &amp;quot;ar&amp;quot; &#39;ranger
    &amp;quot;ad&amp;quot; &#39;dired))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When Evil is in normal or visual state, the prefix is &lt;code&gt;SPC&lt;/code&gt;, as in Spacemacs.
When Evil is in insert or emacs state, the prefix is &lt;code&gt;C-SPC&lt;/code&gt;. We can define some
key under direct access, describe them using Which-key. We can then define
prefix easily, using the &lt;code&gt;:ignore t&lt;/code&gt; keyword. See how close we are from
Spacemacs ?&lt;/p&gt;

&lt;p&gt;So then why not just use Spacemacs and be done with it ? Well, I like the &lt;code&gt;SPC&lt;/code&gt;
prefix thing too much to let the Spacemacs dev decide for me what keybindings
must refer too. I want to make my own Emacs. I want to be able to define
&lt;code&gt;:prefix&lt;/code&gt; easily. I want to understand what Emacs does, without having to read
the entire Spacemacs code base. I want an editor that I can customize to its
inner deepness, without being hit by design choices I did not make.&lt;/p&gt;

&lt;p&gt;And then Spacemacs has one major drawback to me: it is very Qwerty-keyboard
oriented. It means that when you use another keyboard layout, you make some
weird movement just to accomodate Spacemacs keybindings.&lt;/p&gt;

&lt;h3 id=&#34;recipe&#34;&gt;A recipe for a modern Emacs experience&lt;/h3&gt;

&lt;p&gt;I have put up a recipe to build a Spacemacs-like Emacs. It is based on what I
have done systematically, to build a reasonable and very usable emacs to me.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Spot a package that seems interesting.&lt;/li&gt;
&lt;li&gt;Install it using &lt;code&gt;use-package&lt;/code&gt; and its &lt;code&gt;:ensure t&lt;/code&gt; keyword.&lt;/li&gt;
&lt;li&gt;Use it for an hour or two.&lt;/li&gt;
&lt;li&gt;Determine the functions you need.&lt;/li&gt;
&lt;li&gt;Create autoloading for it using &lt;code&gt;use-package&lt;/code&gt; abilities to deferred loading.&lt;/li&gt;
&lt;li&gt;Create a keybinding for it using &lt;code&gt;general&lt;/code&gt;, under the &lt;code&gt;:prefix&lt;/code&gt; you like. Use
&lt;code&gt;SPC&lt;/code&gt; to look like Spacemacs.&lt;/li&gt;
&lt;li&gt;Describe it using &lt;code&gt;which-key&lt;/code&gt; or using the &lt;code&gt;:which-key&lt;/code&gt; keyword of &lt;code&gt;general&lt;/code&gt;
definition.&lt;/li&gt;
&lt;li&gt;There is no other step. Use your package.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I mean, really. You only need those seven steps. You need &lt;code&gt;use-package&lt;/code&gt;,
&lt;code&gt;general&lt;/code&gt;, &lt;code&gt;which-key&lt;/code&gt;. And finally you also need &lt;em&gt;abo-abo&lt;/em&gt; packages. They are
just too awesome.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;Spacemacs is an editor build on top of emacs that is gaining more and more traction among programmers.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;Guess what ELPA means ?
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;Go on and follow him. You won&amp;rsquo;t regret it.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;Check it out &lt;a href=&#34;https://github.com/noctuid/general.el&#34;&gt;here&lt;/a&gt;.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:4&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Integrate iTerm2 in your Emacs setup</title>
      <link>https://sam217pa.github.io/2016/09/01/emacs-iterm-integration/</link>
      <pubDate>Thu, 01 Sep 2016 17:48:38 +0200</pubDate>
      
      <guid>https://sam217pa.github.io/2016/09/01/emacs-iterm-integration/</guid>
      <description>&lt;p&gt;The terminal experience inside emacs being what it is — &lt;em&gt;ie&lt;/em&gt; really slow and
kinda difficult to use —, I use iTerm2 as my main terminal. I put up three
little emacs-lisp functions using AppleScript. They allow me to quickly switch
between iTerm and spacemacs.&lt;/p&gt;

&lt;p&gt;This one return the directory of the file currently opened. If it is a
&lt;code&gt;*scratch*&lt;/code&gt; buffer or something like that, it simply returns the home directory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun get-file-dir-or-home ()
  &amp;quot;If inside a file buffer, return the directory, else return home&amp;quot;
  (interactive)
  (let ((filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
	&amp;quot;~/&amp;quot;
      (file-name-directory filename))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This one allow me to &lt;code&gt;cd&lt;/code&gt; to the directory of the file I am editing in emacs. If
I am in a &lt;code&gt;*scratch*&lt;/code&gt; buffer or something like that, it &lt;code&gt;cd&lt;/code&gt; to the &lt;code&gt;$HOME&lt;/code&gt;
directory. It then focus the iTerm2 app.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun iterm-goto-filedir-or-home ()
  &amp;quot;Go to present working dir and focus iterm&amp;quot;
  (interactive)
  (do-applescript
   (concat
    &amp;quot; tell application \&amp;quot;iTerm2\&amp;quot;\n&amp;quot;
    &amp;quot;   tell the current session of current window\n&amp;quot;
    (format &amp;quot;     write text \&amp;quot;cd %s\&amp;quot; \n&amp;quot; (get-file-dir-or-home))
    &amp;quot;   end tell\n&amp;quot;
    &amp;quot; end tell\n&amp;quot;
    &amp;quot; do shell script \&amp;quot;open -a iTerm\&amp;quot;\n&amp;quot;
    ))
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;EDIT&lt;/em&gt;: 2016-09-05 I have taken Steve Purcell advice into account. Emacs already
have a nice variable called &lt;code&gt;default-directory&lt;/code&gt;. It is set to the directory of
the buffer being edited, or &lt;code&gt;nil&lt;/code&gt; if the buffer does not correspond to a file.
So &lt;code&gt;(or default-directory &amp;quot;~&amp;quot;)&lt;/code&gt; does exactly what we want.&lt;/p&gt;

&lt;p&gt;In case the directory name contains some strange characters like unicode chars
or spaces, we need to escape that before passing to shell. That&amp;rsquo;s exactly what
&lt;code&gt;shell-quote-argument&lt;/code&gt; does. Unfortunately, we need to escape the escaping
characters before passing it as arguments to an applescript statement. Thus the
escaping madness of the next chunk. It now work flawlessly even in directory
like &amp;ldquo;&lt;code&gt;~/Users/me/Google Drive/pâte à pizza/&lt;/code&gt;&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun sam--iterm-goto-filedir-or-home ()
  &amp;quot;Go to present working dir and focus iterm&amp;quot;
  (interactive)
  (do-applescript
   (concat
    &amp;quot; tell application \&amp;quot;iTerm2\&amp;quot;\n&amp;quot;
    &amp;quot;   tell the current session of current window\n&amp;quot;
    (format &amp;quot;     write text \&amp;quot;cd %s\&amp;quot; \n&amp;quot;
            ;; string escaping madness for applescript
            (replace-regexp-in-string &amp;quot;\\\\&amp;quot; &amp;quot;\\\\\\\\&amp;quot;
                                      (shell-quote-argument (or default-directory &amp;quot;~&amp;quot;))))
    &amp;quot;   end tell\n&amp;quot;
    &amp;quot; end tell\n&amp;quot;
    &amp;quot; do shell script \&amp;quot;open -a iTerm\&amp;quot;\n&amp;quot;
    ))
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This last one just focus the iTerm2 app, without modifying the working
directory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(defun iterm-focus ()
  (interactive)
  (do-applescript
   &amp;quot; do shell script \&amp;quot;open -a iTerm\&amp;quot;\n&amp;quot;
   ))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I have mapped it to &lt;code&gt;SPC &#39;&lt;/code&gt; and &lt;code&gt;SPC ?&lt;/code&gt; using &lt;code&gt;general.el&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(general-define-key
 :states &#39;(normal visual insert emacs)
 :prefix &amp;quot;SPC&amp;quot;
  &amp;quot;&#39;&amp;quot; &#39;(iterm-focus :which-key &amp;quot;focus iterm&amp;quot;)
  &amp;quot;?&amp;quot; &#39;(iterm-goto-filedir-or-home :which-key &amp;quot;focus iterm - goto dir&amp;quot;)
  )
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>How I build my own spacemacs</title>
      <link>https://sam217pa.github.io/2016/08/30/how-to-make-your-own-spacemacs/</link>
      <pubDate>Tue, 30 Aug 2016 17:57:03 +0200</pubDate>
      
      <guid>https://sam217pa.github.io/2016/08/30/how-to-make-your-own-spacemacs/</guid>
      <description>

&lt;p&gt;Spacemacs is a great starter kit. It is the only kit that got my attention. I
have been using it for one year or so. I know most of its most useful commands.
I like the plug-and-play feeling of its layer system. I like the laziness of its
packaging system. I like how the devs build a great terminal experience inside
emacs. I like how it abstracts Evil&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; from its users.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://spacemacs.org/img/screenshots/ss1.png&#34; alt=&#34;Spacemacs is a great editor with a great UI.&#34; /&gt;&lt;/p&gt;

&lt;p&gt;But I recently grew tired of its clumsiness. It took like seven or eight second
to load. I tried to remove some configuration layer. I removed chunks of config
I did not need. At its best, Spacemacs took — on my machine&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; — seven long
seconds to load. I gave me the feeling that I did not need most of the full
blown spacemacs distribution. Plus I wanted to understand how to setup my own
emacs. I wanted to tweak it. I wanted to get my hands dirty.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://decentfilms.com/uploads/articles/modern-times.jpg&#34; alt=&#34;Diving into Emacs&#34; /&gt;&lt;/p&gt;

&lt;p&gt;During my year in the spacemacs world, I discovered four awesome packages :
&lt;code&gt;use-package&lt;/code&gt;, &lt;code&gt;general.el&lt;/code&gt;, &lt;code&gt;which-key&lt;/code&gt; and &lt;code&gt;ivy&lt;/code&gt;. They are the backbone of my
new setup.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I only need those four packages to build a good spacemacs experience.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;http://www.lazerhorse.org/wp-content/uploads/2014/11/Peregrine-Falcon-Fastest-Animal-Diving.jpg&#34; alt=&#34;Use-package will make your emacs fast&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;use-package-made-my-emacs-fast&#34;&gt;&lt;code&gt;use-package&lt;/code&gt; made my emacs fast&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;use-package&lt;/code&gt; is a package by the current maintainer of emacs. I use it to load
packages lazily. They will not be loaded unless I call them, or one of
my packages call them. It make the startup super fast&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:5&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:5&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;The following code loads the package which-key, and make sure it is loadable. If
not, it downloads it, thanks to key &lt;code&gt;:ensure&lt;/code&gt; keyword.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(use-package which-key :ensure t
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I use the &lt;code&gt;:init&lt;/code&gt; keyword to execute bits of code before the package is loaded.
The following will enable &lt;code&gt;which-key&lt;/code&gt; in each buffer.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;  :init
  (which-key-mode)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I use the &lt;code&gt;:config&lt;/code&gt; keyword to customize the module to my convenience. Those
bits of code are executed after the package is loaded.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;  :config
  (which-key-setup-side-window-right-bottom)
  (setq which-key-sort-order &#39;which-key-key-order-alpha
        which-key-side-window-max-width 0.33
        which-key-idle-delay 0.05)
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To avoid a cluttered mode-line, I use the &lt;code&gt;diminish&lt;/code&gt; keyword of &lt;code&gt;use-package&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;  :diminish which-key-mode
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I could also use the following syntax, to replace the &lt;code&gt;WK&lt;/code&gt; in the mode-line with
&lt;code&gt;Ꙍ&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:3&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;  :diminish (which-key-mode . &amp;quot;Ꙍ&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://www.ed.ac.uk/files/styles/panel_breakpoints_theme_uoe_desktop_1x/public/thumbnails/image/istock_000048893782_double-900.jpg?itok=yaFi-FYU&#34; alt=&#34;Use unicode in your mode-line&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Here I showed you how I use &lt;code&gt;use-package&lt;/code&gt; to load a package that is enabled
globally at startup. But &lt;code&gt;use-package&lt;/code&gt; has many option to make sure the package
is not loaded if nobody needs it. I use the &lt;code&gt;:commands&lt;/code&gt; keyword to load the
package when a command in the list of command is called.&lt;/p&gt;

&lt;p&gt;For example, if I want to use the &lt;code&gt;ranger&lt;/code&gt; package, I do not need it until I
call the &lt;code&gt;(ranger)&lt;/code&gt; function. So I put &lt;code&gt;(ranger)&lt;/code&gt; in the list of commands that
will trigger the loading of &lt;code&gt;ranger&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(use-package ranger :ensure t
  :commands (ranger)
  :bind ((&amp;quot;C-x d&amp;quot; . deer))
  :config
  (setq ranger-cleanup-eagerly t)
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;use-package&lt;/code&gt; also provide the &lt;code&gt;:bind&lt;/code&gt; keyword. I use it to describe the list of
commands that will trigger the loading of my package, and the keybindings that
I want to associate with the command. In the previous example, I mapped
&lt;code&gt;(deer)&lt;/code&gt; to &lt;code&gt;C-x d&lt;/code&gt;. So, unless I call &lt;code&gt;(ranger)&lt;/code&gt; before typing &lt;code&gt;C-x d&lt;/code&gt;, the
&lt;code&gt;ranger&lt;/code&gt; package will not load.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This is the magic of use-package.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/b1298535828025bd6dada5abbb8661b43c7c7785/687474703a2f2f692e696d6775722e636f6d2f535841363679372e706e67&#34; alt=&#34;General.el is a great package to make a short spacemacs-like config&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;general-el-made-my-evil-shine&#34;&gt;&lt;code&gt;general.el&lt;/code&gt; made my evil shine&lt;/h3&gt;

&lt;p&gt;General.el is the new evil-leader black. It makes it easy to implement leader
keys, of any length you want. It also has nice integration with &lt;code&gt;use-package&lt;/code&gt;
and &lt;code&gt;which-key&lt;/code&gt;. Its primary use is in combination with &lt;code&gt;evil&lt;/code&gt;, but you can also
use it with bare emacs.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(use-package general :ensure t
  :config
  (general-evil-setup t)

  (general-define-key
   :states &#39;(normal insert emacs)
   :prefix &amp;quot;C-SPC&amp;quot;
   :non-normal-prefix &amp;quot;C-SPC&amp;quot;
   &amp;quot;l&amp;quot; &#39;(avy-goto-line)
   &amp;quot;a&amp;quot; &#39;align-regexp
   )

  (general-define-key
   :states &#39;(normal motion insert emacs)
   :prefix &amp;quot;SPC&amp;quot;
   &amp;quot;ar&amp;quot; &#39;(ranger :which-key &amp;quot;call ranger&amp;quot;)
   &amp;quot;g&amp;quot;  &#39;(:ignore t :which-key &amp;quot;Git&amp;quot;)
   &amp;quot;gs&amp;quot; &#39;(magit-status :which-key &amp;quot;git status&amp;quot;)
   )
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The previous chunks load the &lt;code&gt;general&lt;/code&gt; package at startup. This one is not
lazily loaded. It uses &lt;code&gt;(general-define-key)&lt;/code&gt; to define keys that are under the
prefix &lt;code&gt;C-SPC&lt;/code&gt;. When the evil-state is not normal, &lt;em&gt;ie&lt;/em&gt; when I am in insert or
visual mode, the prefix is also &lt;code&gt;C-SPC&lt;/code&gt;, but I can set it to something
different. So when I press &lt;code&gt;C-SPC&lt;/code&gt; then &lt;code&gt;l&lt;/code&gt;, it calls &lt;code&gt;avy-goto-line&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The next chunks is all it takes to setup a Spacemacs-like interface to my
favorite commands using the space bar as a prefix. Like in spacemacs, &lt;code&gt;SPC ar&lt;/code&gt;
calls ranger. Notice the &lt;code&gt;:which-key&lt;/code&gt; keyword. Use it to describe your
keybindings. The string I use will be displayed by the &lt;code&gt;which-key&lt;/code&gt; package. Use
the &lt;code&gt;:ignore&lt;/code&gt; keyword when the key-press is only a prefix, and you want to
describe the prefix via &lt;code&gt;which-key&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.doaks.org/library-archives/library-and-archives-banner-images/ICFA%20Archives_Landscape_02.jpg&#34; alt=&#34;Reading emacs documentation&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;which-key-will-make-your-emacs-friendly&#34;&gt;&lt;code&gt;which-key&lt;/code&gt; will make your emacs friendly&lt;/h3&gt;

&lt;p&gt;The obvious benefit of spacemacs to me is its discoverability. Press a key, read
the description of the prefix, press another key, etc…&lt;/p&gt;

&lt;p&gt;&lt;code&gt;which-key&lt;/code&gt; is a package that prints out a buffer of all the keybindings
currently assigned to the prefix you type. In the previous example, if I type
&lt;code&gt;C-x&lt;/code&gt;, then a buffer prints out:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s15.postimg.org/5ufo1lst7/whichkeybuffer.png&#34; alt=&#34;whichkeybuffer.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;It is a listing of all the keyboard shortcut starting with &lt;code&gt;C-x&lt;/code&gt;. But what if I
want to know what is behind the &lt;code&gt;RET&lt;/code&gt; keypress ? &lt;code&gt;which-key&lt;/code&gt; provide a way to
describe a prefix.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(which-key-add-key-based-replacements
    &amp;quot;C-x RET&amp;quot; &amp;quot;coding system - input&amp;quot;
 )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So now when I press &lt;code&gt;C-x&lt;/code&gt;, I see:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s21.postimg.org/52vaaat7b/whichkeybuffer_cxret.png&#34; alt=&#34;whichkeybuffer-cxret.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Those three packages all belongs in the spacemacs universe, &lt;code&gt;general.el&lt;/code&gt; being
only an upgrade over &lt;code&gt;evil-leader&lt;/code&gt;. The spacemacs dev chose to use &lt;code&gt;helm&lt;/code&gt; as a
default &amp;ldquo;incremental completion and selection narrowing frameworks&amp;rdquo;. But
recently, a proficient and prolific emacs package developper&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:6&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:6&#34;&gt;5&lt;/a&gt;&lt;/sup&gt; build an ecosystem
of tools based on its variation of &lt;code&gt;ido&lt;/code&gt;. Those packages are &lt;code&gt;ivy&lt;/code&gt;, &lt;code&gt;counsel&lt;/code&gt;
and &lt;code&gt;swiper&lt;/code&gt;. They represent a great alternative to the somewhat clumsy helm
ecosystem.&lt;/p&gt;

&lt;h3 id=&#34;ivy-extend-my-mind-inside-emacs&#34;&gt;&lt;code&gt;ivy&lt;/code&gt; extend my mind inside emacs&lt;/h3&gt;

&lt;p&gt;Just like &lt;code&gt;helm&lt;/code&gt; or &lt;code&gt;ido&lt;/code&gt;, &lt;code&gt;ivy&lt;/code&gt; is a &amp;ldquo;generic completion framework&amp;rdquo;. It shines
at being unobtrusive and really fast. I was really surprised by the fact that I
could reimplement most of my most used spacemacs commands on top of &lt;code&gt;ivy&lt;/code&gt; or its
associated package &lt;code&gt;counsel&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;ivy-mode ensures that any Emacs command using completing-read-function uses
ivy for completion. Counsel takes this further, providing versions of common
Emacs commands that are customised to make the best use of ivy.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Here is my &lt;code&gt;(use-package)&lt;/code&gt; declaration for &lt;code&gt;ivy&lt;/code&gt; and &lt;code&gt;counsel&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;(use-package ivy :ensure t
  :diminish (ivy-mode . &amp;quot;&amp;quot;) ; does not display ivy in the modeline
  :init (ivy-mode 1)        ; enable ivy globally at startup
  :bind (:map ivy-mode-map  ; bind in the ivy buffer
         (&amp;quot;C-&#39;&amp;quot; . ivy-avy)) ; C-&#39; to ivy-avy
  :config
  (setq ivy-use-virtual-buffers t)   ; extend searching to bookmarks and …
  (setq ivy-height 20)               ; set height of the ivy window
  (setq ivy-count-format &amp;quot;(%d/%d) &amp;quot;) ; count format, from the ivy help page
  )

(use-package counsel :ensure t
  :bind*                           ; load counsel when pressed
  ((&amp;quot;M-x&amp;quot;     . counsel-M-x)       ; M-x use counsel
   (&amp;quot;C-x C-f&amp;quot; . counsel-find-file) ; C-x C-f use counsel-find-file
   (&amp;quot;C-x C-r&amp;quot; . counsel-recentf)   ; search recently edited files
   (&amp;quot;C-c f&amp;quot;   . counsel-git)       ; search for files in git repo
   (&amp;quot;C-c s&amp;quot;   . counsel-git-grep)  ; search for regexp in git repo
   (&amp;quot;C-c /&amp;quot;   . counsel-ag)        ; search for regexp in git repo using ag
   (&amp;quot;C-c l&amp;quot;   . counsel-locate))   ; search for files or else using locate
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;swiper&lt;/code&gt; is an &lt;code&gt;isearch&lt;/code&gt; replacement based on ivy. It is really really fast. I
have tried it on huge files&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:4&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:4&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;. It still is really really fast. I have the
feeling it is much faster than &lt;code&gt;helm-swoop&lt;/code&gt;, though I did not measured it. I
bind it to &lt;code&gt;C-s&lt;/code&gt;, the default keyboard press to isearch.&lt;/p&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;Here I showed you how I used those four packages and their ecosystem to build
myself a great spacemacs-like experience. In the next post, I want to spend some
time on helping you build your own experience of emacs. I will use those
packages to describe you how you could build yourself a great emacs environment,
using modern tools.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;Evil is The vim emulation inside emacs. It makes emacs behave exactly as vim. Try it if you want to keep your carpal tunnel.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;A 2011 MacBook Pro with 16G of RAM and a Samsung SSD.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:5&#34;&gt;Like one-second fast.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:5&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;Yes, you can and should use unicode.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:6&#34;&gt;See its github profile &lt;a href=&#34;https://github.com/abo-abo&#34;&gt;here&lt;/a&gt;.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:6&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;I have tried it, just like the maintainer, by copy-pasting org.el multiple time in itself. The file was like 1G bytes huge. Swiper did not tremble.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:4&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>War of the languages</title>
      <link>https://sam217pa.github.io/2016/06/30/war-of-the-languages/</link>
      <pubDate>Thu, 30 Jun 2016 12:52:33 +0200</pubDate>
      
      <guid>https://sam217pa.github.io/2016/06/30/war-of-the-languages/</guid>
      <description>

&lt;h1 id=&#34;chosing-a-language&#34;&gt;Chosing a language&lt;/h1&gt;

&lt;p&gt;I&amp;rsquo;ve been trying to make up my mind about which programming languages I should
know. I&amp;rsquo;ve come to the conclusion that I must know what matters to me. That&amp;rsquo;s
not a very exciting conclusion.&lt;/p&gt;

&lt;p&gt;But when you&amp;rsquo;re starting off in a new field, you are very curious about chosing
the right tool for the job. You wander around on the internet, read some pros
and cons of some particular language, start to learn about it, read some more
pros and cons, switch to a new language, repeat.&lt;/p&gt;

&lt;p&gt;When I began to learn some data science tools on
&lt;a href=&#34;https://www.coursera.org/specializations/jhu-data-science&#34;&gt;Coursera&lt;/a&gt; two years
ago, I did not know which language to pick. They introduced &lt;code&gt;R&lt;/code&gt;, so I sticked
with &lt;code&gt;R&lt;/code&gt;. And I came to love it. I learned about the most useful packages and
all that. Learned some graphics techniques too&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:ggplot2-to-the-r&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:ggplot2-to-the-r&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. This
time was great. I was not comparing &lt;code&gt;R&lt;/code&gt; to other languages. I knew only about
&lt;code&gt;R&lt;/code&gt;. I was not saying &amp;ldquo;Oh, I wish &lt;code&gt;R&lt;/code&gt; could do that!&amp;rdquo; or &amp;ldquo;If only &lt;code&gt;R&lt;/code&gt; was as
clean as &lt;code&gt;Python&lt;/code&gt;&amp;rdquo;. I sticked to &lt;code&gt;R&lt;/code&gt;, and learned a ton. It reminds me of the
period of life where people usually learn the most : childhood. Just thinking
about the mass of information we have to face as a baby is incredible. The
process of learning a first programming language is really similar. We have to
face many information simultaneously : what is a for
loop&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:Not-in-R-of-cour&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:Not-in-R-of-cour&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;, what is a terminal, what is an IDE, what is a
function, where are my data, how do I learn about X, what was the name of this
function already, I wish I knew of a function that could do this and that, what
is the name of these functions&amp;rsquo; arguments, …&lt;/p&gt;

&lt;p&gt;And then, when I was getting familiar with common hacking techniques, I grew
curious about what was on the other side. Maybe Python is cool too. I checked
Python. What ? No &lt;code&gt;library(foo)&lt;/code&gt; ? Python3 is so different from Python2 that I
have to use a &lt;code&gt;virtualenv&lt;/code&gt; ? What is a &lt;code&gt;virtualenv&lt;/code&gt; ? How do I set up all this ?
&lt;code&gt;R&lt;/code&gt; was so much simpler. I guess there is other languages that are closer to &lt;code&gt;R&lt;/code&gt;
and simpler to use than python. Well, &lt;code&gt;julia&lt;/code&gt; is. Let&amp;rsquo;s learn some &lt;code&gt;julia&lt;/code&gt;. Oh
but wait, &lt;code&gt;julia&lt;/code&gt; is only 0.3.2. I cannot use &lt;code&gt;julia&lt;/code&gt; for now. Nobody knows
it. But hey, I learned about speed of executions. I now know that R is
slow. Maybe I can learn a compiled language like C ? Maybe it would be a good
idea to know what the community think about a good first language to pick ? (Go
on stackoverflow). Ok, what ? Structure and Interpretation of Computer Programs
? This is the second time I hear this name. I know Hadley suggests it as a good
introduction to functional programming in &lt;code&gt;R&lt;/code&gt;. Let&amp;rsquo;s read it. &lt;code&gt;Scheme&lt;/code&gt; ?
Parenthesis everywhere. Simple syntax. Lego for the mind. Ok then let&amp;rsquo;s learn
Scheme. But Scheme is nowhere to be seen in a production environment. What the …
is a production environment ? Maybe let&amp;rsquo;s learn some Clojure then. Ok so I need
to learn about the JVM ? Clojure is functional programming on the JVM, like
Scala. Scala ? Syntax similar to &lt;code&gt;R&lt;/code&gt;, good constructs and all. But Scala is so
java like that you have to use a dedicated IDE. And I love emacs. Well then not
Scala. Maybe Clojure ? But wait.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What&amp;rsquo;s the point ?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;what-do-i-need-from-a-programming-language&#34;&gt;What do I need from a programming language ?&lt;/h1&gt;

&lt;p&gt;I need it to be simple to use. I do not want to be a software engineer. I want
to be able to analyse data. I want to be able to look at a biological data set,
and get meanings from it. I do not need to know about GUI or stuff like
that. Maybe &lt;code&gt;R&lt;/code&gt; was a good choice after all. Maybe I could check out what is the
most used language in my field ? Ok then it&amp;rsquo;s &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;Python&lt;/code&gt;. Well, let&amp;rsquo;s
stick to &lt;code&gt;R&lt;/code&gt;, and learn some &lt;code&gt;Python&lt;/code&gt; to wrangle some sequences.&lt;/p&gt;

&lt;p&gt;Now I&amp;rsquo;m glad I did all that. It took me a year or so. But now I know why I am at
my computer. I learned some pretty amazing stuff. But now I can focus on what is
important to me as a data scientist : I want an analysis environment that is
simple to use, closer to the data than to the metal, in which I can quickly
abstract ideas&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:functional-progr&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:functional-progr&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;, and if
needed, that I can make faster easily&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:looking-at-you-R&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:looking-at-you-R&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;R&lt;/code&gt; is all that. You can interface it with C++ seamlessly with dedicated
package, to make it really really fast. Yet you can stay in your REPL all along,
never worrying about the implementations details, never worrying about where
your class is defined, what was the button of that IDE that did this, where was
the button of that other IDE that did that, which software version am I using,
if I develop some code, will it be easy to deploy to another computer, not using
macOS like me ? &lt;code&gt;R&lt;/code&gt; is a great environment in this regard. It abstracts many
things from the data analyst, and make his life really easy.&lt;/p&gt;

&lt;h1 id=&#34;use-r-learn-python-learn-c&#34;&gt;Use R. Learn Python. Learn C++&lt;/h1&gt;

&lt;p&gt;As a final advice to anybody reading this, which like me, is trying to find his
place in this world of software engineers and bioinformatician. You don&amp;rsquo;t want
to be a software engineer. You want to analyse data. This is not your job to
build up the algorithm of that particular piece of software, or the details of
the implementation of a particular class or object. You want to know what is
this gene doing. You want to know why this bacteria is always associated with
this particular plant. You want to know why it is that a bacteria can be composed
of 13% of GC, and another of 76%. There is some data associated with it.&lt;/p&gt;

&lt;p&gt;Use python to make your data available to R. Python is very good at wrangling
data, like perl was in its glory days. When the data is in R, use the right tool
for the job. If a function is slow, try another approach. Try to vectorize
it. Try to make it simpler. Use optimized functions. When it&amp;rsquo;s still slow, use
C++. Those are the three tools one need to turn most analysis from an idea to a
reality.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:ggplot2-to-the-r&#34;&gt;&lt;code&gt;ggplot2&lt;/code&gt; to the rescue ! &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:ggplot2-to-the-r&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:Not-in-R-of-cour&#34;&gt;Not in &lt;code&gt;R&lt;/code&gt; of course ;) &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:Not-in-R-of-cour&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:functional-progr&#34;&gt;functional programming was a good idea after all… &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:functional-progr&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:looking-at-you-R&#34;&gt;looking at you Rcpp and Cython &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:looking-at-you-R&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Using LaTeX</title>
      <link>https://sam217pa.github.io/2016/06/07/using-latex/</link>
      <pubDate>Tue, 07 Jun 2016 14:33:06 +0200</pubDate>
      
      <guid>https://sam217pa.github.io/2016/06/07/using-latex/</guid>
      <description>&lt;p&gt;LaTeX is a great tool.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve recently used it to write my master&amp;rsquo;s memoir (accessible
&lt;a href=&#34;https://www.dropbox.com/s/6btccuw8hudxvgo/rapport.pdf?dl=0&#34;&gt;here&lt;/a&gt;). I used Tikz
to draw simple diagrams. They are really simple, yet I do not know of any other
tool that I could use to produce these diagrams. In their first implementation,
those diagrams integrated rather tightly text and figures. I said it before, and
I say it again : I am firmly convinced that Tufte is right about integrating
visual evidence with text. The Old Masters like &lt;em&gt;da Vinci&lt;/em&gt; and &lt;em&gt;Galileo&lt;/em&gt; did it.
That was normal at the time: text was written with the support of visual
evidence. They used ink.&lt;/p&gt;

&lt;p&gt;We use computers. That makes the idea of laying down text and visual evidence
together more difficult. We are used to separate it. One page for text, one page
for figures. Sometimes the text describes something that is not even seeable by
the reader, because the corresponding figure is on the next page.&lt;/p&gt;

&lt;p&gt;LaTeX and Tikz allow us to do that much more naturally. It really is simple to
integrate text, maths, figures, drawing, photos and diagrams together. Plus it
is free. It is really moldable, you can lead LaTeX to draw anything you want.
Search on Google, you will see some great examples of Phd Thesis written in
LaTeX with great figures and diagrams. Nobody can do it inside Microsoft Word.
Maybe it could be done inside Adobe InDesign, but I have no experience with it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://sam217pa.github.io/images/recombinaison.png&#34; alt=&#34;Homologous Recombination During Natural Transformation&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Migrating to Hugo</title>
      <link>https://sam217pa.github.io/2016/06/06/switch-to-hugo/</link>
      <pubDate>Mon, 06 Jun 2016 20:08:11 +0200</pubDate>
      
      <guid>https://sam217pa.github.io/2016/06/06/switch-to-hugo/</guid>
      <description>

&lt;p&gt;I quit Jekyll today. Not a really huge decision to make, the blog is really
small at this point. I could convert all metadata and all by hand. That was
before I knew that Hugo has some tools to ease the switch.&lt;/p&gt;

&lt;h1 id=&#34;so-long-jekyll&#34;&gt;So long Jekyll&lt;/h1&gt;

&lt;p&gt;I got tired of Jekyll for two reasons. The first is that I had a lot of stuff to
install before being able to serve and test my website. The second is that it is
a hell to maintain a blog with it. The last post I wrote
(&lt;a href=&#34;http://sam217pa.github.io/2016/02/06/2016-02-06-emacs-in-my-toolbox/&#34;&gt;here&lt;/a&gt;)
was published with Jekyll. That was before I upgraded to El Capitan. All hell
went lose after that. Some dependencies were upgraded too, and stuff I&amp;rsquo;ve done
four months ago were to be done again. I don&amp;rsquo;t have a clue about the &lt;code&gt;Ruby&lt;/code&gt;
ecosystem, and I&amp;rsquo;m not particularly interested in learning it. I know it is
really simple, but I don&amp;rsquo;t have the time nor the motivation to.&lt;/p&gt;

&lt;h1 id=&#34;hi-hugo&#34;&gt;Hi Hugo&lt;/h1&gt;

&lt;p&gt;I chosed Hugo for two reasons. The first is that I had great experiences with
tools written in &lt;code&gt;Go&lt;/code&gt; recently, mainly &lt;a href=&#34;https://github.com/junegunn/fzf&#34;&gt;fzf&lt;/a&gt;
and &lt;a href=&#34;https://github.com/monochromegane/the_platinum_searcher&#34;&gt;pt&lt;/a&gt;. I had taken a
look at &lt;a href=&#34;https://github.com/urfave/cli&#34;&gt;cli&lt;/a&gt; when I was looking for a simple way
to write a command line app&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:I-ended-up-using&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:I-ended-up-using&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;, and it looked dead simple. &lt;code&gt;Go&lt;/code&gt;-based tools seems to have a &amp;ldquo;keep it
simple stupid&amp;rdquo; spirit that appeals to me very much. The second reason is that
Hugo has an awesome &lt;a href=&#34;https://gohugo.io/&#34;&gt;website&lt;/a&gt; and
&lt;a href=&#34;https://gohugo.io/overview/introduction/&#34;&gt;documentation&lt;/a&gt; that makes it really
easy to have a quick overview of what it can do.&lt;/p&gt;

&lt;p&gt;Since I don&amp;rsquo;t need really complex stuff to be done in a simple blog, I thought
Hugo was a great choice. Its speed was the icing on the cake. I tend to think
that I don&amp;rsquo;t need it. But when you have it, you don&amp;rsquo;t look back. Same goes for
&lt;code&gt;ag&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To deploy the website to GitHub Pages, simply &lt;code&gt;git init&lt;/code&gt; in the &lt;code&gt;public&lt;/code&gt;
directory, and &lt;code&gt;git remote add&lt;/code&gt; your repo URL. GitHub Pages are generated at
super speed. This is really simple.&lt;/p&gt;

&lt;p&gt;I would definitely recommend Hugo to anybody wanting to start a blog. I find it
really simple to use, much more than Jekyll. And it has great themes.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:I-ended-up-using&#34;&gt;I ended up using &lt;a href=&#34;http://click.pocoo.org/5/&#34;&gt;click&lt;/a&gt; with Python. Great library, although it tends to introduce some clumsiness in the app &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:I-ended-up-using&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Changing my Emacs Paradigm</title>
      <link>https://sam217pa.github.io/2016/06/06/emacs-changing-paradigm/</link>
      <pubDate>Mon, 06 Jun 2016 19:47:05 +0200</pubDate>
      
      <guid>https://sam217pa.github.io/2016/06/06/emacs-changing-paradigm/</guid>
      <description>

&lt;p&gt;In my previous
&lt;a href=&#34;http://sam217pa.github.io/2016/02/06/2016-02-06-emacs-in-my-toolbox/&#34;&gt;post&lt;/a&gt;, I
talked about the way I tended to integrate everything in Emacs. In this one, I
want to describe what lead me to totally change the way I use it.&lt;/p&gt;

&lt;h1 id=&#34;living-in-the-terminal&#34;&gt;Living in the terminal&lt;/h1&gt;

&lt;p&gt;I just spend four months in front of my computer. I literally lived inside my
terminal for various reasons. I had biological data to analyse, and software to
develop to do it. I used &lt;code&gt;R&lt;/code&gt;, &lt;code&gt;bash&lt;/code&gt;, &lt;code&gt;perl&lt;/code&gt; and &lt;code&gt;Python&lt;/code&gt; and read some &lt;code&gt;C&lt;/code&gt; code
too. The diversity of languages we have to face when working in the
bioinformatics field is incredible. For that I was lucky to have chosen to learn
polyglot &lt;code&gt;vi&lt;/code&gt; and &lt;code&gt;emacs&lt;/code&gt; in the past. Not being locked to a particuliar IDE
when facing that much diversity is a great thing.&lt;/p&gt;

&lt;h1 id=&#34;developping-inside-emacs&#34;&gt;Developping inside emacs&lt;/h1&gt;

&lt;p&gt;At the beginning, I was doing exactly what I described in my previous post. I
lived inside org-mode, using code blocks to put up software and describe what
each piece of code was doing. I then tangled each block to its file, tested it,
went back to org-mode, debugged it, tangled it, tested it … At the end of the
day, that makes a lot of &lt;code&gt;C-u C-u C-c C-v
t&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:org-babel-tangle&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:org-babel-tangle&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;I had to speed up the way I wrote software, particularly when I was facing very
tight deadlines. I really gradually started not to use org-mode to organise
source code. Then I was not using it at all. Even my TODO notes migrated to
&lt;a href=&#34;https://taskwarrior.org/&#34;&gt;taskwarrior&lt;/a&gt;, a great command line tool with very
similar abilities as org-mode. The only benefit it has is being accessible from
the command line really fast. Just type &lt;code&gt;alias T=&#39;task&#39;&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; to have a brief
overview of what&amp;rsquo;s to be done.&lt;/p&gt;

&lt;p&gt;Then I (re)learned to use &lt;a href=&#34;https://tmux.github.io/&#34;&gt;tmux&lt;/a&gt;, and started to
harness the emacs daemon feature. It boosted my productivity a great deal. Just
add&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;export EDITOR=&amp;quot;emacsclient -t&amp;quot;
export ALTERNATE_EDITOR=&amp;quot;&amp;quot;

alias e=&#39;emacsclient -t&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to your &lt;code&gt;.bashrc&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:or-zshrc-you-sho&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:or-zshrc-you-sho&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;, and you&amp;rsquo;re all
set to use emacs as your main editor. You can have as many tmux sessions you
want, there is only one emacs instance to edit all the file you edit. It makes
integrating emacs and the typical terminal environment, with all its speed and
comfort, really nicer.&lt;/p&gt;

&lt;p&gt;I recommend it to everyone searching for a way to integrate emacs within its
terminal. I remember being very destabilized when I quit vim to emacs by the
fact that emacs was really slow to open a simple file. I ended up using only the
graphical emacs, but had to switch between emacs and the terminal quite often.
To be honest, the &lt;code&gt;shell&lt;/code&gt;, &lt;code&gt;ansiterm&lt;/code&gt;, &lt;code&gt;eshell&lt;/code&gt; and all are not that great for
now inside emacs. It feels very clumsy and slow, and result in all sort of bugs
when emacs tries to syntax highlight everything.&lt;/p&gt;

&lt;p&gt;I mapped &lt;code&gt;server-edit&lt;/code&gt; to &lt;code&gt;SPC-.&lt;/code&gt; inside Spacemacs, so that I can quickly switch
between emacs and the terminal environment.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:org-babel-tangle&#34;&gt;&lt;code&gt;org-babel-tangle&lt;/code&gt;, when given two prefix arguments, tangles only the block that correponds to the same output file. This function is really great.  &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:org-babel-tangle&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:or-zshrc-you-sho&#34;&gt;or &lt;code&gt;.zshrc&lt;/code&gt;, you should obviously use zsh. &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:or-zshrc-you-sho&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Recombination and the evolution of base composition in prokaryotic genomes</title>
      <link>https://sam217pa.github.io/project/projet-gbc/</link>
      <pubDate>Mon, 06 Jun 2016 16:44:43 +0200</pubDate>
      
      <guid>https://sam217pa.github.io/project/projet-gbc/</guid>
      <description>

&lt;h1 id=&#34;what-s-all-the-fuss-about-base-composition&#34;&gt;What&amp;rsquo;s all the fuss about base composition ?&lt;/h1&gt;

&lt;p&gt;Every genome is made of only four nucleotides : Adenine, Thymine, Guanine and
Cytosine. By convention, biologists describe base composition of genomes in term
of GC content, or GC%.&lt;/p&gt;

&lt;p&gt;$$
GC\% = \frac{GC}{AT + GC}
$$&lt;/p&gt;

&lt;p&gt;Base composition is a fundamental genome trait. It typically varies many fold
over the genome, and between genome. Since fifty years, microbial GC-content
diversity has been described&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:See-for-example&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:See-for-example&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.
Now that we can massively sequence a lot of genome, we know that GC% is even
more variable than expected. Extremely reduced genomes of insect endosymbionts
typically have low GC%. &lt;em&gt;Carsonella rudii&lt;/em&gt; is the most AT rich genome sequenced
to date. On the other side of the distribution, large genomes of soil bacteria
have GC content around 70%, like &lt;em&gt;Streptomyces&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The origin of such variability has been the topic of many debates since fifty
years. Some authors have proposed that GC% is under selection, that the GC%
contributes to individual fitness in a given environment. Several lines of
evidence tends to indicate that environmental parameters may be related to GC%,
like oxygen or nitrogen availability, or optimal growth temperature&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;. But
correlations between such factors and base composition are weak at best, and are
often not robust to analysis in a powerful phylogenetic framework, &lt;em&gt;ie&lt;/em&gt; taking
phylogenetic inertia into account. Thus, the favoured hypothesis since 1962 and
the famous work of Sueoka &lt;em&gt;et al&lt;/em&gt;, was that divergence in mutational bias
patterns was the main determinants of base composition variability. Sueoka
proposed that GC-rich genomes may have more mutations toward G and C, while
AT-rich genomes may have more mutations toward A and T. This hypothesis have
popularized the idea that base composition is mostly determined by a neutral
process : mutation.&lt;/p&gt;

&lt;h1 id=&#34;2010-mutational-bias-hypothesis-shattered&#34;&gt;2010 : Mutational bias hypothesis shattered&lt;/h1&gt;

&lt;p&gt;Sueoka&amp;rsquo;s idea was the dominant school of thought during fifty years. This
hypothesis was broken into pieces by one issue of Plos Genetics&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;, in which two
famous geneticists team independently and simultaneously demonstrated that
mutation is universally biased towards AT, even in GC-rich genomes. They also
showed that some kind of evolutionary force tends to increase GC content in all
genomes. Consequences of this two paper may well represent a &amp;ldquo;seismic shift of
paradigm&amp;rdquo; in microbial evolution, as coined by Rocha &amp;amp; Feil&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:3&#34;&gt;4&lt;/a&gt;&lt;/sup&gt; in their review
paper. It can only mean one thing : some selection or selection-like process is
increasing GC content in bacteria.&lt;/p&gt;

&lt;h1 id=&#34;why-not-gc-biased-gene-conversion&#34;&gt;Why not GC-biased gene conversion ?&lt;/h1&gt;

&lt;p&gt;In eucaryotes, it has been shown that recombination affects GC content.
Recombination involves pairing of homologous strands of DNA into a structure
called an &lt;em&gt;heteroduplex&lt;/em&gt;. Mismatch between strands are corrected by a specific
mechanism, which tends to introduce more GC bases than AT. The process of
mismatch repair leads to gene conversion, &lt;em&gt;ie&lt;/em&gt; the unidirectional transfer of
genetic information from the donor strand to the corrected strand. In mammals
and probably a great deal of eucaryotic organisms, gene conversion is biased
towards GC, which means that GC:AT mismatch are more often corrected into GC
than AT. The GC-biased gene conversion (gBGC) consequences have been thoroughly
reviewed by Duret &amp;amp; Galtier in &lt;a href=&#34;10.1146/annurev-genom-082908-150001&#34;&gt;this&lt;/a&gt; 2009
paper. The major consequences is that recombination hotspots (intensely
recombining genomic regions) are GC-richer than coldspots. One can draw a very
strong correlation between GC-content of a genomic region and its
crossover-rate&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:4&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:4&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;By increasing GC-alleles fixation probability over AT-alleles, gBGC has a
selection-like signature in genomes. When the two 2010 papers came out, my
supervisor thought that maybe gene conversion is also biased toward GC in
bacteria ! Florent Lassalle, during is PhD, thus looked for traces of
recombination in bacterial genomes, using comparative genomic tools&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:lassalle&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:lassalle&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;. He binned
genomes into twenty distinct GC% bins, and found that the proportion of
recombining genes in a given bin is correlated to its GC%. He also found that
GC% is higher in recombining genes, and even higher at third codon positions.
Due to genetic code redundancy, the third codon position is less strongly
subject to purifying selection.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;All these observations are compatible with the gBGC hypothesis.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;what-s-my-job&#34;&gt;What&amp;rsquo;s my job ?&lt;/h1&gt;

&lt;p&gt;But observations only are what they are : observations. It would be great if we
could experimentally test that gene conversion is biased or not in bacterial
models. My first goal is thus to measure the frequency of conversion of GC:AT
mismatch toward GC and AT. I will force mismatch by using synthetic sequences
that introduces single nucleotide variants at a given locus, and sequence the
recombination products. We need many recombining bacteria. We chose to use
natural transformation in &lt;em&gt;Acinetobacter baylyi&lt;/em&gt;, known for its high
transformation frequencies.&lt;/p&gt;

&lt;p&gt;My second goal is to estimate fundamental recombination related traits, like
recombination rate per base and global effective population size. We want to
confront those measures with known GC-content affecting environmental traits and
fundamental genome properties, like genome size. The idea is to check for
recombination related confounding patterns in previously advanced
GC%-determining traits.&lt;/p&gt;

&lt;p&gt;Maybe we&amp;rsquo;ll then have a more solid overview of what may be at stake in this ever
evading property of bacterial genomes…&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34;
  src=&#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&#34;&gt;
&lt;/script&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:See-for-example&#34;&gt;See for example the work of Hill &lt;em&gt;et al&lt;/em&gt;, 1966 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:See-for-example&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:1&#34;&gt;Optimal Growth Temperature was thought to be positively correlated to GC% in the nineties, but this theory has been refuted since. See the work of Galtier &lt;em&gt;et al&lt;/em&gt;, 1997. They demonstrated that only structural RNA-encoding DNA GC% is correlated to GC%. There is no significant correlation between GC content and OGT.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;See &lt;a href=&#34;http://dx.doi.org/10.1371/journal.pgen.1001107&#34;&gt;this&lt;/a&gt; work by Hildebrand &lt;em&gt;et al&lt;/em&gt;, and &lt;a href=&#34;http://dx.plos.org/10.1371/journal.pgen.1001115&#34;&gt;this&lt;/a&gt; work by Hershberg &amp;amp; Petrov.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;See &lt;a href=&#34;http://dx.doi.org/10.1371/journal.pgen.1001104&#34;&gt;here&lt;/a&gt;.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;See &lt;a href=&#34;10.1371/journal.pgen.1000071&#34;&gt;this&lt;/a&gt; work by Duret &amp;amp; Arndt on the impact of recombination on nucleotide substitutions in the human genome.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:4&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:lassalle&#34;&gt;His &lt;a href=&#34;10.1371/journal.pgen.1004941&#34;&gt;paper&lt;/a&gt; has been published in Plos Genetics in 2015.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:lassalle&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Emacs in My Toolbox</title>
      <link>https://sam217pa.github.io/2016/02/06/2016-02-06-emacs-in-my-toolbox/</link>
      <pubDate>Sat, 06 Feb 2016 15:42:58 +0100</pubDate>
      
      <guid>https://sam217pa.github.io/2016/02/06/2016-02-06-emacs-in-my-toolbox/</guid>
      <description>

&lt;p&gt;Emacs is a powerful tool. A frequent habit of emacs user is to try to migrate
everything they know and use inside emacs. Emacs Gnus or mu4e, both emacs mail
clients, emacs org-mode, a GTD mode inside emacs—which is actually extremely
powerful—, emacs calc, a calculator inside emacs etc… are all attempts in this
line of conduct.&lt;/p&gt;

&lt;p&gt;As an emacs user myself, I also tried these stuff. And it works really well.&lt;/p&gt;

&lt;p&gt;As a matter of fact, I actually use it all day long. Let&amp;rsquo;s describe quickly how
I use it to work.&lt;/p&gt;

&lt;h1 id=&#34;emacs-matters&#34;&gt;Emacs Matters&lt;/h1&gt;

&lt;p&gt;I start emacs as I start my OS. I used to check mails with mu4e, but never
really loved the UI. I check my agenda for the day, built with org-mode. I set
up my main tasks for the day, putting some time-stamps on it.&lt;/p&gt;

&lt;h1 id=&#34;programming-and-documenting-at-the-same-time&#34;&gt;Programming and documenting. At the same time.&lt;/h1&gt;

&lt;p&gt;I then open the README.org of the project I&amp;rsquo;m currently working on, which
involves a lot of bash scripting, python and R. All these scripts are written
inside the README.org, with comments and all written in org-mode. Scripts are
written inside &lt;code&gt;src&lt;/code&gt; blocks, and tangled to a src directory containing all my
tangled files. I never ever edit a single tangled files. I always do it inside
org-mode, so that I can describe my work, what I try to do, what I already did
and what&amp;rsquo;s left to do at the end of the day. My workflow is thus entirely
managed inside emacs. I can put TODO flags in different parts of the project,
organise the src code in different header tree etc…&lt;/p&gt;

&lt;h1 id=&#34;org-mode-to-pdf&#34;&gt;Org-mode to pdf&lt;/h1&gt;

&lt;p&gt;When the time comes to write a report, I write it inside org-mode. I use zotero
to export my references to a &lt;code&gt;.bib&lt;/code&gt; file somewhere on my computer. Org-ref is a
mode to manage citations and references inside org-mode. I already wrote a 30
pages long report with figures, references, math and all inside org-mode. I
export to latex, and use &lt;code&gt;latexmk&lt;/code&gt; to export my report to pdf.&lt;/p&gt;

&lt;p&gt;Emacs is great. Let&amp;rsquo;s all use emacs.
&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:I-actually-use-S&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:I-actually-use-S&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:I-actually-use-S&#34;&gt;I actually use Spacemacs, a combination of Vim and Emacs. It&amp;rsquo;s great if you plan to stay all day at the computer : your pinky will thank you for that. It&amp;rsquo;s all the more true if you have it broken like me ! &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:I-actually-use-S&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Lectures and Data Visualization</title>
      <link>https://sam217pa.github.io/2015/10/21/2015-10-21-lectures-and-datavis/</link>
      <pubDate>Wed, 21 Oct 2015 20:40:26 +0200</pubDate>
      
      <guid>https://sam217pa.github.io/2015/10/21/2015-10-21-lectures-and-datavis/</guid>
      <description>

&lt;p&gt;Powerpoints are everywhere. In our world of science, Powerpoints are the &lt;em&gt;lingua
franca&lt;/em&gt; of lectures. Yet they are seldom used to their rightful potential. I
believe Powerpoints are often accused of the lecturer&amp;rsquo;s fault. I speak here with
the legitimacy of a student that spent most of the last six years listening to
lecturers with poor lecturing skills&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:I-am-not-saying&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:I-am-not-saying&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;I am a great admirer of Edward Tufte&amp;rsquo;s work about data visualization. Yet I
disagree with his opinion that Powerpoints kills reasoning. Actually I believe
there are many overlaps between good data visualization and good lectures.&lt;/p&gt;

&lt;p&gt;Here are Tufte&amp;rsquo;s opinion on graphical excellence. Good graphics :&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;show the data&lt;/li&gt;
&lt;li&gt;induce the viewer to think about substance rather than methodology, design
or something else.&lt;/li&gt;
&lt;li&gt;avoid distorting the data.&lt;/li&gt;
&lt;li&gt;present many number in a small space.&lt;/li&gt;
&lt;li&gt;make large data sets coherent.&lt;/li&gt;
&lt;li&gt;reveal the data at several levels of details, from a broad overview to a
fine structure.&lt;/li&gt;
&lt;li&gt;serve a clear purpose.&lt;/li&gt;
&lt;li&gt;be closely integrated with the statistical and verbal description of the
data.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;As a matter of fact, a good lectures shares the same objectives. Good lectures :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;show the question.&lt;/li&gt;
&lt;li&gt;induce the listener to think about substance rather than the lecturer&amp;rsquo;s style of lecturing.&lt;/li&gt;
&lt;li&gt;avoid distorting the question&lt;/li&gt;
&lt;li&gt;present many complex facts and ideas in a small space.&lt;/li&gt;
&lt;li&gt;make complex, multivariate questions coherent.&lt;/li&gt;
&lt;li&gt;reveals the ins and outs of the question at several levels of details, from a
broad overview to the finest technical details.&lt;/li&gt;
&lt;li&gt;serve a clear purpose.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here I&amp;rsquo;ll expose what I think makes a good
lecturer&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:I-ll-talk-indiff&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:I-ll-talk-indiff&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;.
It follows Tufte&amp;rsquo;s ideas on data visualization.&lt;/p&gt;

&lt;h2 id=&#34;good-lecturers-show-the-question&#34;&gt;Good lecturers show the question&lt;/h2&gt;

&lt;p&gt;A Powerpoint and a lecturer are useless if the scientific question behind it is
not understood by the audience.&lt;/p&gt;

&lt;p&gt;A good Powerpoint should always have a clear title. It describes clearly and
concisely the broad topic. It serves its goal even better as a question.
Questions gives direction to reasoning.&lt;/p&gt;

&lt;h2 id=&#34;good-lecturers-have-a-good-style&#34;&gt;Good lecturers have a good style.&lt;/h2&gt;

&lt;p&gt;This is my main point. Good lecturers induces the listener to think about the
&lt;em&gt;question&lt;/em&gt;. The listener should not have to think about the lecture&amp;rsquo;s style. To
paraphrase Pr Hervé Maisonneuve :&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Good style is absence of style.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Color that serves no goal should disappear. Forget Powerpoints ready-made
templates. They have no place in Science. Superfluous words should disappear.
Diagrams are clear. They take the space they need, no more.&lt;/p&gt;

&lt;p&gt;Indeed, I do agree with Edward Tufte that Powerpoints should be reserved for
pictures, diagrams and charts. In Science, we can put all aspects of reasoning
to good use. Some people needs a visual support to information. But the
excessive use of Powerpoints has shifted this support from the lecturer to the
screen. We need to realize this. The support of information is the lecturer. The
audience should be &lt;em&gt;listening&lt;/em&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:Listening-is-a-s&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:Listening-is-a-s&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;. Not staring at a screen,
trying to make sense of verbless sentences.&lt;/p&gt;

&lt;p&gt;Poor lecturers tend to put too much textual information on screen. As if they
were hoping that it could rescue their audience&amp;rsquo;s lack of attention…&lt;/p&gt;

&lt;p&gt;As does good charts, good lecturers are neutral enough to shift focus from form
to content.&lt;/p&gt;

&lt;h2 id=&#34;good-lecturers-do-not-distort-the-question&#34;&gt;Good lecturers do not distort the question.&lt;/h2&gt;

&lt;p&gt;Good lecturers do not leave an opinionated point of view of the question in the
listener&amp;rsquo;s mind. On the contrary, they should be subtle enough to put the seeds
of good reasoning in it. The listener has the choice to make it flourish.&lt;/p&gt;

&lt;h2 id=&#34;good-lecturers-synthesize&#34;&gt;Good lecturers synthesize.&lt;/h2&gt;

&lt;p&gt;Good lecturers show many elements to the listener. They give him keys to analyze
those elements. Or they can lead him to get this keys by
himself&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:It-depends-on-th&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:It-depends-on-th&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;But they have to be synthetic. One cannot hope to give a sufficiently broad
overview of a complex topic with too much divergence from the central point.&lt;/p&gt;

&lt;h2 id=&#34;good-lecturers-show-complexity&#34;&gt;Good lecturers show complexity.&lt;/h2&gt;

&lt;p&gt;Good lecturers connect facts between them. Good lecturers connect theories
between them. They connect theories to facts. They connect facts to theories.
They connect it to the audience&amp;rsquo;s knowledge. One can not be a good lecturer
without knowing his audience.&lt;/p&gt;

&lt;p&gt;A good lecturer&amp;rsquo;s main role is to make complex questions coherent.&lt;/p&gt;

&lt;h2 id=&#34;good-lecturers-show-details-and-perspective&#34;&gt;Good lecturers show details and perspective&lt;/h2&gt;

&lt;p&gt;A good lecturer has the ability to attach the finest details to the broader
tendency in which they are included. He knows the broad phenomena as well as
little peculiar details.&lt;/p&gt;

&lt;h2 id=&#34;good-lecturers-serves-a-clear-purpose&#34;&gt;Good lecturers serves a clear purpose.&lt;/h2&gt;

&lt;p&gt;It could be the #1 point. Good lecturers put things in context. Period. One can
never have the listener&amp;rsquo;s attention if the listener does not know why he should
listen. What is the point of this ? Why are you doing this ? Why work on this ?
To what point ?&lt;/p&gt;

&lt;p&gt;Such questions are so common that a lecturer tends to forget to answer it.&lt;/p&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;Tufte says a chart&amp;rsquo;s data to ink ratio should be maximized. Chartjunk should be
eliminated.&lt;/p&gt;

&lt;p&gt;I say ideas to speak ratio is the measure of a lecture&amp;rsquo;s quality. Talkjunk is
needless. So many talk are crippled with useless information that it is rather
the rule than the exception.&lt;/p&gt;

&lt;p&gt;Focus should be on the lecturer. Not on the screen. The lecturer&amp;rsquo;s focus should
be on the listener. Not on the screen.&lt;/p&gt;

&lt;p&gt;Powerpoints are a tool to assist reasoning. Not a support of information. Not a
decoration. They should be neutral. They should be the hammer of the lecturer. A
tool.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:I-am-not-saying&#34;&gt;I am not saying here that all of the lectures I had were of poor quality. I say most of them. &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:I-am-not-saying&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:I-ll-talk-indiff&#34;&gt;I&amp;rsquo;ll talk indifferently of lecturer or Powerpoint. To me, a Powerpoint is as bad as is its designer. &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:I-ll-talk-indiff&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:Listening-is-a-s&#34;&gt;Listening is a skill we have to re-learn. Powerpoints have made that much damage. &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:Listening-is-a-s&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:It-depends-on-th&#34;&gt;It depends on the lecturer&amp;rsquo;s style. Even though he should not have a style. Ha. &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:It-depends-on-th&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Biased Gene Conversion</title>
      <link>https://sam217pa.github.io/2015/10/17/2015-10-17-biased-gene-conversion/</link>
      <pubDate>Sat, 17 Oct 2015 15:17:18 +0200</pubDate>
      
      <guid>https://sam217pa.github.io/2015/10/17/2015-10-17-biased-gene-conversion/</guid>
      <description>

&lt;p&gt;Base composition of genomes is affected by many major process, being either
neutral or selective. The neutral model describes mutations as following the
genetic drift, which depends on population effective size. It does not represent
the genome reality very well, but it is a useful model as a null hypothesis. One
must reject the neutral hypothesis before affirming that a genomic trait is under
selection constraints.&lt;/p&gt;

&lt;h1 id=&#34;natural-selection-hypothesis&#34;&gt;Natural Selection hypothesis&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;A curious aspect of the theory of evolution is that everybody thinks he
understands it. &lt;em&gt;Jacques Monod&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The natural selection hypothesis discriminate three cases of a genomic trait
being under selective constraints. The positive or directional selection leads
to the gradual erasing of variation on a given position of the genome, if this
position has a positive impact on the fitness. The purifying, or negative
selection, act against all variation, nearly all mutation are deleterious.
Typically, a mutation on conserved region of 16S rDNA in Bacteria are
deleterious : they does not spread in the population.&lt;/p&gt;

&lt;p&gt;Recently, a new process that can confound selection tracks with a neutral
process has been discovered : the biased gene conversion.&lt;/p&gt;

&lt;h1 id=&#34;gene-conversion&#34;&gt;Gene conversion&lt;/h1&gt;

&lt;p&gt;A gene conversion event takes place when the resolution of the intermediate
poroduct of homolog recombination leads to the
uni-directional—non-reciprocal—exchange of genetic information from one donor to
a receptor sequence. It is a key process of the first meiosis division, an
obligate step in eukaryotes gametogenesis.&lt;/p&gt;

&lt;p&gt;Nevertheless, if one allele has a greater chance to be the donor, the process is
biased.&lt;/p&gt;

&lt;h1 id=&#34;biased-gene-conversion&#34;&gt;Biased Gene Conversion&lt;/h1&gt;

&lt;p&gt;There are two main scenarios to explain a biased gene conversion event.&lt;/p&gt;

&lt;h2 id=&#34;initiation-bias&#34;&gt;Initiation bias&lt;/h2&gt;

&lt;p&gt;The initiation bias appears when a region on one double stranded DNA is more
often victim of double strand breaks than its homolog region on the sister
chromosome. This region is thus called a recombination hotspots, whereas its
homolog on the sister chromosome is called a recombination coldspots.
Paradoxically, on the lifespan of the hotspot, the coldspot will more often be
the donor of gene conversion events, leading to the gradual death of the
corresponding hotspot. There is an initiation bias on the gene conversion event.&lt;/p&gt;

&lt;h2 id=&#34;gc-biased-gene-conversion&#34;&gt;GC-biased gene conversion&lt;/h2&gt;

&lt;p&gt;The other bias is called GC-bias gene conversion. Indeed, it has been shown in
many eukaryotes, including yeast and human, that the G or C alleles of a gene
are statistically significantly more often the donor of a gene conversion event
than its A or T corresponding allele.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;It looks exactly as directed selection, but is &lt;em&gt;not&lt;/em&gt; an adaptative process.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;One can find traces of GC-bias gene conversion in a region if all positions are
affected, being either neutral or &lt;em&gt;even deleterious&lt;/em&gt;. Typically, gBGC is
associated with regions of high rate of recombination, actual or past. While
selection only act on non neutral regions&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:3&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;, gBGC also acts on nearby introns
and non-functional sequences. Moreover, selection can act on a very large
genomic scale, when linkage is taken into account.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;gBGC has been shown to be responsible for the large scale variations of
GC-content, the so called genomic isochores; it can lead to the fixation of
deleterious mutations; and it can confound traces of selection.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:3&#34;&gt;exons or regulatory sequences
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Hill-Robertson Effects</title>
      <link>https://sam217pa.github.io/2015/10/15/2015-10-15-hill-robertson-effects/</link>
      <pubDate>Thu, 15 Oct 2015 19:06:40 +0200</pubDate>
      
      <guid>https://sam217pa.github.io/2015/10/15/2015-10-15-hill-robertson-effects/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;Hill-Robertson effects are interference between two locus under selection. When
recombination is weak, selection on the two locus interfere. Selection is less
efficient than when it acts on two independent locus.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Consider &lt;em&gt;A&lt;/em&gt; and &lt;em&gt;B&lt;/em&gt;, two moderately advantageous allele, in different
population. They are under positive or directional selection. If recombination
is weak, an optimal &lt;em&gt;AB&lt;/em&gt; combination can never appear. &lt;em&gt;A&lt;/em&gt; and &lt;em&gt;B&lt;/em&gt; interfere
with each other.&lt;/p&gt;

&lt;p&gt;Those are the typical Hill-Robertson effects, as described by Hill and Robertson
in 1966. They have been described under other declination since.&lt;/p&gt;

&lt;h2 id=&#34;selective-sweep&#34;&gt;Selective Sweep&lt;/h2&gt;

&lt;p&gt;Consider &lt;em&gt;A&lt;/em&gt;, a strongly advantageous allele, and &lt;em&gt;b&lt;/em&gt; a weakly deleterious
allele. &lt;em&gt;b&lt;/em&gt; is linked to &lt;em&gt;A&lt;/em&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:They-are-in-link&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:They-are-in-link&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. The
advantageous effects of &lt;em&gt;A&lt;/em&gt; leads to its invasion in the population. It can even
lead to a point of fixation. It is thus a selective sweep of &lt;em&gt;A&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;But &lt;em&gt;b&lt;/em&gt; is linked to &lt;em&gt;A&lt;/em&gt;. &lt;em&gt;b&lt;/em&gt; will also invade the population, even if it is
deleterious. This is a case of &amp;ldquo;genetic hitch-hiking&amp;rdquo;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:As-coined-by-Joh&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:As-coined-by-Joh&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;h2 id=&#34;background-selection&#34;&gt;Background selection&lt;/h2&gt;

&lt;p&gt;It is the opposite case of selective sweep interference. Consider now &lt;em&gt;B&lt;/em&gt;, a
strongly deleterious allele, and &lt;em&gt;a&lt;/em&gt; a weakly advantageous allele. &lt;em&gt;a&lt;/em&gt; is linked
to &lt;em&gt;B&lt;/em&gt;. The deleterious effects of &lt;em&gt;B&lt;/em&gt; lead to the extinction of &lt;em&gt;B&lt;/em&gt; carrying
individuals.&lt;/p&gt;

&lt;p&gt;But &lt;em&gt;a&lt;/em&gt; is linked to &lt;em&gt;B&lt;/em&gt;. &lt;em&gt;a&lt;/em&gt; will disappear from the population, even if it is
advantageous. This is a case of background selection. All polymorphism linked to
a strongly deleterious allele is purged.&lt;/p&gt;

&lt;h2 id=&#34;muller-s-ratchet&#34;&gt;Muller&amp;rsquo;s Ratchet&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Muller&amp;rsquo;s ratchet was first described in 1932.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It happens in clonal species, with small population sizes. A population carrying
no deleterious mutation is a population subgroup. When the first deleterious
mutation appears, the population ratchets up on the mutational burden. Since
recombination is weak, given the small population size, this mutation has no
chance to be cured. When further deleterious mutation occurs, population
degenerate. Its fitness irresistibly drops down, to the point of extinction.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Hill-Robertson effects only occurs when recombination is weaker than mutation.
Polymorphism decreases and selection efficacy decreases too. One must consider
selection intensity, mutation and recombination respective rates. The size of
the genomic window affected depends on those three parameters : if recombination
is weak and selection strong, genome can be affected on a large scale.&lt;/p&gt;

&lt;p&gt;Hill-Robertson effects can explain counter intuitive observations. The spread of
deleterious allele can be explained by genomic interference, as is the case with
cystic fibrosis.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:They-are-in-link&#34;&gt;They are in &lt;em&gt;linkage desequilibrium&lt;/em&gt; &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:They-are-in-link&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:As-coined-by-Joh&#34;&gt;As coined by John Maynard Smith&amp;rdquo; &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:As-coined-by-Joh&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>